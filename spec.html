<!DOCTYPE html>
<html lang="en">
<head>
  <title>UNL - Unified Navigation Language - Final Specification v1.0</title>
  <meta charset="UTF-8">
  <script src="https://www.w3.org/Tools/respec/respec-w3c" class="remove"></script>
  
  <script class="remove">
    var respecConfig = {
      specStatus: "unofficial",
      shortName: "unl-spec-en",
      subtitle: "Final Specification v1.0",
      editors: [
        { name: "Specification Provided by User" }
      ],
      github: "https://github.com/mozasaur/unl",
      issueBase: "https://github.com/mozasaur/unl/issues/",
    };
  </script>
</head>
<body>

  <section id="abstract">
    <h2>Abstract</h2>
    <p>
      The Unified Navigation Language (UNL) is designed as an embeddable query language. This specification describes its syntax, data model, type system, and the necessary components of an execution environment for integration into a host programming language. UNL provides a single, coherent syntax to query, navigate, and transform data across multiple structured formats, including XML, JSON, CSV, and RDF.
    </p>
  </section>

  <section id="sotd">
    </section>
  
  <section id="intro">
    <h2>Introduction</h2>
    <p>
      In an increasingly heterogeneous data ecosystem, developers must master multiple query languages (XPath for XML, JSONPath for JSON, SPARQL for RDF, etc.). UNL was designed to eliminate this complexity by offering a unified abstraction layer.
    </p>
    <p>
      UNL's key innovations are:
    </p>
    <ul>
      <li><strong>Optional Navigation <code>?</code>:</strong> A unique syntax to elegantly handle variable or incomplete data structures.</li>
      <li><strong>Node/Leaf Distinction (<code>@</code>):</strong> Provides fundamental semantic clarity by distinguishing between navigable containers and final values.</li>
      <li><strong>Advanced Structural Navigation (<code>outer()</code>):</strong> Enables complex, type-based navigation jumps that are difficult to achieve with other languages.</li>
      <li><strong>Fluid Transformations (<code>|format</code>):</strong> The pipe operator allows for on-the-fly data conversion within a single navigation expression.</li>
      <li><strong>Native URI and Namespace Support:</strong> Full integration with semantic web standards (RDF, XML) via EQName syntax.</li>
      <li><strong>Unified Syntax:</strong> One language to rule all your formats.</li>
    </ul>
    <h3>Design Principles</h3>
    <ul>
      <li><strong>LALR(1) Parsable:</strong> The grammar is designed to be unambiguous and easily parsable.</li>
      <li><strong>Extensible:</strong> The system can incorporate new formats without changing the core parser.</li>
      <li><strong>Compatible:</strong> It is inspired by the best ideas from XPath and CSS without creating conflicts.</li>
      <li><strong>Intuitive:</strong> The syntax is designed to be read naturally.</li>
    </ul>
  </section>

  <section id="conformance">
      </section>
  
  <section id="execution-models">
      <h2>Operating Models</h2>
      <p>A UNL query is always evaluated against an initial context. The initial context can be a single document or a sequence of documents.</p>
      
      <section id="in-memory-nav">
          <h3>In-Memory Navigation</h3>
          <p>
              In this model, the UNL engine operates on a data structure that is already parsed and held in memory. The context can be a single root <a>Node</a> or a sequence of <a>Nodes</a>. The UNL query is an expression that navigates this existing structure directly. This corresponds to the <code>InMemoryQuery</code> production in the EBNF grammar.
          </p>
          <pre class="example">
// context: Node(Object)
let myJson = { "user": { "name": "John" } };
// query: String
let inMemoryQuery = "user/@name";

// unl.run(context: Node, query: String) → Sequence(Leaf)
let result = unl.run(myJson, inMemoryQuery);
// result is a Sequence containing one item: Leaf("John")
          </pre>
      </section>
      
      <section id="resource-loading-nav">
          <h3>Resource Loading and Navigation</h3>
          <p>
              In this model, the UNL query begins with a <strong>Resource Locator</strong>. This locator can be a single resource identifier (a file path or a URI) or a pattern (e.g., a glob) that resolves to a sequence of resources. This locator is immediately followed by a mandatory transformation pipe (<code>|</code>) that instructs the engine how to fetch and parse the resource(s). This corresponds to the <code>ResourceQuery</code> production in the EBNF grammar.
          </p>
          <div class="note">
            <h4>Important Note on Resource Locators</h4>
            <p>
                The <code>ResourceLocator</code> part of a query is treated as a literal string path or URI. It only supports the standard <code>/</code> as a path separator. The special UNL navigation operators such as <code>?</code> (optional navigation), <code>@</code> (leaf access), or wildcards are not valid within the locator itself. UNL's navigation logic is only applied to the path expression that follows the first transformation pipe.
            </p>
          </div>
          <pre class="example nohighlight">
// query: String (A ResourceQuery)
let resourceQuery = "data.csv|csv/*[1]/@price";

// unl.run(query: String) → Sequence(Leaf)
let result = unl.run(resourceQuery);
// result is a Sequence containing one item: Leaf("some_price")
          </pre>
      </section>
  </section>

  <section id="host-language-integration">
    <h2>Host Language Integration</h2>
    <p>
        UNL is designed to be embedded within a host programming language (e.g., Python, JavaScript, Java). A UNL engine implementation <em class="rfc2119">MUST</em> be provided with an <strong>Execution Environment</strong> by the host. This environment supplies the context and configurations necessary to execute a query.
    </p>
    <p>The components of the Execution Environment are:</p>
    <dl>
        <dt>Initial Context</dt>
        <dd>This is the data upon which the UNL query will run. It corresponds to one of the <a href="#execution-models">Operating Models</a>: either a pre-parsed object/node (for In-Memory Navigation) or a string/list of strings representing Resource Locators.</dd>
        
        <dt>Namespace Mappings</dt>
        <dd>For queries involving prefixed QNames (e.g., <code>foaf:name</code>), the host environment <em class="rfc2119">MUST</em> provide a mapping of prefixes to their full namespace URI strings. This is typically a hash map or dictionary. The UNL engine uses this map to resolve EQNames.
        </dd>

        <dt>Variable Bindings (Optional)</dt>
        <dd>To write secure and reusable queries, an implementation <em class="rfc2119">SHOULD</em> support external variable binding. Variables within a UNL query are denoted with a `$` prefix (e.g., <code>$username</code>). The host environment can provide a map of variable names to their values. These values are mapped to UNL's conceptual data types, and can be primitive <a>Leaves</a> (String, Number, Boolean) or structured <a>Nodes</a> (Object, Array).
            <pre class="example nohighlight">
// Pseudo-code for variable binding
let variables = {
  "user_id": 123,
  "allowed_roles": ["admin", "editor"]
};
// Use a numeric variable in a predicate
unl.run(context, "users[@id = $user_id]", { variables });
// Use an array variable in a predicate
unl.run(context, "users[role = $allowed_roles]");
            </pre>
        </dd>

        <dt>Custom Function Library (Optional)</dt>
        <dd>For advanced extensibility, an implementation <em class="rfc2119">MAY</em> allow the host language to register custom functions. To prevent name collisions with built-in functions, custom functions <em class="rfc2119">MUST</em> be namespaced. The host environment provides a mapping of namespace prefixes to collections of functions.
            <pre class="example">
// Pseudo-code for registering and using a custom function
// my_validators.js
const is_internal_email = (email_string) => email_string.endsWith('@example.com');
const is_strong_password = (pwd_string) => pwd_string.length > 12;

// Main application
unl.registerFunctionLibrary("validate", { isInternal: is_internal_email, isStrong: is_strong_password });

unl.run(context, "//user[validate:isInternal(@email)]");
            </pre>
        </dd>
    </dl>
    <div class="note">
        <h4>Note on `current()`</h4>
        <p>A dedicated `current()` function is not necessary in UNL. The `.` operator always refers to the current context node at any point in a path, which serves the same purpose in a more concise, standard way.</p>
    </div>
  </section>
  
  <section id="sequence-handling">
    <h2>Sequence Transformations</h2>
    <p>
        UNL includes a powerful two-stage pipeline model to process sequences of results. This allows for both efficient, low-memory streaming and complex, full-sequence aggregations.
    </p>
    
    <section>
        <h3>The Streaming Pipeline (<code>|</code>)</h3>
        <p>
            The default pipeline, using the single pipe <code>|</code>, operates in a streaming fashion. Each operator processes items one by one as they arrive, typically with minimal memory overhead (<code>O(1)</code> or `O(k)`). This model is highly efficient for large datasets. It includes format parsing, decoding, and a class of "streamable aggregates".
        </p>
        <h4>Streamable Aggregate Operators</h4>
        <p>These operators can produce their result without needing to store the entire sequence in memory. They operate in the standard streaming pipeline.</p>
        <table>
            <thead>
                <tr><th>Operator</th><th>Description</th><th>Type Signature</th></tr>
            </thead>
            <tbody>
                <tr><td><code>| head(n)</code></td><td>Takes the first <code>n</code> items from the stream and terminates the pipeline.</td><td><code>Sequence(T) → Sequence(T)</code></td></tr>
                <tr><td><code>| tail(n)</code></td><td>Maintains a fixed-size buffer to output the last <code>n</code> items once the stream ends.</td><td><code>Sequence(T) → Sequence(T)</code></td></tr>
                <tr><td><code>| count</code></td><td>Counts all items in the stream and outputs a single leaf with the total at the end.</td><td><code>Sequence(T) → Leaf(Number)</code></td></tr>
                <tr><td><code>| sum</code></td><td>Calculates the sum of all items in a numeric stream.</td><td><code>Sequence(Leaf(Number)) → Leaf(Number)</code></td></tr>
                <tr><td><code>| avg</code></td><td>Calculates the average of all items in a numeric stream.</td><td><code>Sequence(Leaf(Number)) → Leaf(Number)</code></td></tr>
                <tr><td><code>| min</code></td><td>Finds the minimum value in a stream of comparable items.</td><td><code>Sequence(T) → T</code></td></tr>
                <tr><td><code>| max</code></td><td>Finds the maximum value in a stream of comparable items.</td><td><code>Sequence(T) → T</code></td></tr>
            </tbody>
        </table>
    </section>
    
    <section>
        <h3>The Aggregation Pipeline (<code>||</code>)</h3>
        <p>
            The double pipe <code>||</code> acts as a <strong>blocking barrier</strong>. It instructs the engine to stop streaming, collect all results from the preceding pipeline into a full sequence in memory (<code>O(n)</code>), and then pass that complete sequence to the aggregation operators that follow. This is a conscious trade-off made by the user to enable powerful, whole-sequence operations.
        </p>
        <h4>Blocking Aggregate Operators</h4>
        <p>These operators <em class="rfc2119">MUST</em> be preceded by the <code>||</code> barrier, as they require the entire sequence to be available to perform their work.</p>
        <table>
            <thead>
                <tr><th>Operator</th><th>Description</th><th>Type Signature</th></tr>
            </thead>
            <tbody>
                <tr><td><code>| order-by(key)</code></td><td>Sorts the entire sequence based on a key expression.</td><td><code>Sequence(T) → Sequence(T)</code></td></tr>
                <tr><td><code>| group-by(key)</code></td><td>Groups items in the sequence based on a key expression.</td><td><code>Sequence(T) → Sequence(Node(Group))</code></td></tr>
                <tr><td><code>| distinct</code></td><td>Removes duplicate items from the sequence.</td><td><code>Sequence(T) → Sequence(T)</code></td></tr>
            </tbody>
        </table>
        <div class="note">
            <h4>Final Query Results</h4>
            <p>The result of a UNL query is the data produced by the final operator in the pipeline. If the pipeline ends with an aggregation operator like <code>order-by</code> or `distinct`, the result is a sequence (an array of nodes or leaves). The task of serializing this final sequence into a specific document format (e.g., by wrapping it in a root element) is left to the calling application or environment.</p>
        </div>
    </section>
  </section>

  <section id="core-concepts">
    <h2>Fundamental Principles</h2>
    <p>
      UNL's data model is based on three core principles.
    </p>
    <dl>
      <dt><dfn>Node</dfn> (No Prefix)</dt>
      <dd>Represents a navigable structure that contains other <a>nodes</a> or leaves. Examples: an XML element, a JSON object, a CSV row represented as a node.</dd>
      
      <dt><dfn>Leaf</dfn> (<code>@</code> Prefix)</dt>
      <dd>Represents a final, non-navigable atomic value. It is the endpoint of a navigation path. Examples: a string, a number, a boolean value, or a node's metadata attribute.</dd>
      
      <dt>The Pipe Transformation Principle (<code>|</code> Operator)</dt>
      <dd>
        A <a>Leaf</a> is normally a terminal point of navigation. However, the pipe operator <code>|</code> allows the value of a Leaf to be re-interpreted as a new data source. This operation performs a <strong>type-casting</strong> of the leaf's value, creating a new, navigable <a>Node</a> structure. This mechanism is the key to nested parsing and is fundamental to UNL's power.
        <br/>
        Symbolically: <code>.../<a>Leaf</a>(String) |json → New <a>Node</a>(JSON)</code>
      </dd>
    </dl>
  </section>
  
  <section id="type-system">
    <h2>Type System and Comparisons</h2>
    <p>UNL operates on a set of conceptual data types defined in the <a href="#data-mapping">Data Model Mapping</a> appendix. The behavior of comparison and equality operators depends on these types.</p>
    
    <section>
        <h3>Equality (`=` and `!=`)</h3>
        <p>The equality operator compares two values. The inequality operator `!=` is defined as the negation of `=`. The rules are applied in order:</p>
        <ol>
            <li>If one operand is a sequence of multiple items, the comparison is true if the other operand is equal to <strong>any</strong> item in the sequence.</li>
            <li>If both operands are of the same primitive type (e.g., Number, String, Boolean), they are compared by value.</li>
            <li><strong>Type Coercion:</strong> If operands are of different primitive types, the engine attempts to coerce them to a common type before comparison. The primary rule is to attempt casting to a Number. For example, `5 = "5"` is true. If coercion fails, the items are not equal.</li>
            <li>If one operand is a <a>Node</a> and the other is a primitive <a>Leaf</a>, the node's "string value" (e.g., its text content for an XML element) is used for the comparison. For example, `book/title = "UNL"` is true if the text content of the title element is "UNL".</li>
        </ol>
    </section>

    <section>
        <h3>Ordered Comparisons (`<`, `>`, `<=`, `>=`)</h3>
        <p>Ordered comparisons are primarily defined for primitive, orderable types (Numbers, Strings).</p>
        <ul>
            <li>The same type coercion rules as for equality apply. Operands will be cast to a numeric type if possible before comparison.</li>
            <li>Comparing a <a>Node</a> with an ordered operator uses its string value.</li>
            <li>An ordered comparison against a sequence is generally not defined and its behavior may be implementation-dependent.</li>
        </ul>
    </section>

    <section>
        <h3>Sorting (`order-by`)</h3>
        <p>
            The `| order-by(key)` operator uses these comparison rules to sort a sequence. It evaluates the `key` expression for each item in the sequence, and then sorts the items based on the resulting key values. The host implementation <em class="rfc2119">SHOULD</em> provide options to specify data type (e.g., numeric vs. text) for sorting to avoid ambiguity.
        </p>
    </section>
  </section>

  <section id="syntax">
    <h2>Navigation Syntax</h2>
    
    <section id="nav-base">
      <h3>Base Navigation</h3>
      <table>
        <thead>
          <tr><th>Operator</th><th>Description</th></tr>
        </thead>
        <tbody>
          <tr><td><code>/</code></td><td>Mandatory navigation to a child. Must exist.</td></tr>
          <tr><td><code>?</code></td><td>Optional navigation between nodes. Allows chaining paths that may not exist (<code>a?b</code> is equivalent to <code>a</code> or <code>a/b</code>).</td></tr>
          <tr><td><code>?</code> (wildcard)</td><td>Single wildcard when used alone. Represents any single child (<code>a/?/c</code>).</td></tr>
          <tr><td><code>*</code></td><td>Multiple wildcard. Represents all child <a>nodes</a>.</td></tr>
          <tr><td><code>**</code></td><td>Descendant wildcard. Represents all descendant <a>nodes</a>.</td></tr>
          <tr><td><code>.</code></td><td>Represents the current <a>node</a>.</td></tr>
          <tr><td><code>@name</code></td><td>Accesses a named <a href="#dfn-leaf">leaf</a>.</td></tr>
          <tr><td><code>@*</code></td><td>Selects all <a href="#dfn-leaf">leaves</a> of the current <a>node</a> as an ordered collection.</td></tr>
          <tr><td><code>#id</code></td><td>Direct access to a <a>node</a> by its ID or URI.</td></tr>
        </tbody>
      </table>
    </section>
    
    <section id="nav-vertical">
      <h3>Vertical Navigation (Ancestors)</h3>
      <table>
        <thead>
          <tr><th>Operator</th><th>Description</th></tr>
        </thead>
        <tbody>
          <tr><td><code>..</code></td><td>Direct parent.</td></tr>
          <tr><td><code>..n</code></td><td>Nth ancestor (e.g., <code>..2</code> for the grandparent).</td></tr>
          <tr><td><code>...</code></td><td>All ancestors up to the root.</td></tr>
        </tbody>
      </table>
    </section>
    
    <section id="nav-lateral">
      <h3>Lateral Navigation (Siblings)</h3>
      <table>
        <thead>
          <tr><th>Operator</th><th>Description</th></tr>
        </thead>
        <tbody>
          <tr><td><code>+</code></td><td>The immediate following-sibling.</td></tr>
          <tr><td><code>-</code></td><td>The immediate preceding-sibling.</td></tr>
          <tr><td><code>~</code></td><td>All following-siblings.</td></tr>
          <tr><td><code>~~</code></td><td>All preceding-siblings.</td></tr>
        </tbody>
      </table>
    </section>
  </section>

  <section id="special-chars">
    <h2>Handling Special Characters and Quoting</h2>
    <p>
        Many characters have a special syntactic meaning in UNL (e.g., <code>/ ? @ * [ ] ( ) | . :</code>). If a node or leaf name in the source data contains one of these characters, it must be enclosed in single (<code>'</code>) or double (<code>"</code>) quotes to be treated as a literal name.
    </p>
    <p>
        This quoting mechanism applies to any path segment that is a name test.
    </p>
    
    <h3>Rules for Quoting</h3>
    <dl>
        <dt>When to Quote</dt>
        <dd>A name segment <em class="rfc2119">MUST</em> be quoted if it contains any special UNL characters or if it is ambiguous with a numeric literal (e.g., a key named "3").</dd>
        
        <dt>Escaping within Quotes</dt>
        <dd>To include a quote character within a quoted name, it <em class="rfc2119">MUST</em> be escaped with a backslash (<code>\</code>). A literal backslash <em class="rfc2119">MUST</em> also be escaped (<code>\\</code>).</dd>
    </dl>
    
    <h3>Examples</h3>
    <pre class="example">
// Example 1: JSON key with a forward slash
// Data: { "a/b": { "c": 1 } }
// Query: "a/b"/c/@value

// Example 2: Filename with special characters
// Resource Locator: my-archive.zip
// Path in zip: reports/report-[v1].xml
my-archive.zip|decomp:zip/reports/"report-[v1].xml"|xml//...

// Example 3: XML element name with dots
// Data: &lt;com.example.Node&gt;Value&lt;/com.example.Node&gt;
// Query: "com.example.Node"/text()

// Example 4: Quoting a name containing quotes
// Data: { "node with \"quotes\"": 42 }
// Query: "node with \\\"quotes\\\""/@value
    </pre>
  </section>

  <section id="uris-namespaces">
    <h2>URIs and Namespaces</h2>
    <p>
        UNL provides robust support for namespaced data formats like XML and RDF. To ensure unambiguous queries, UNL adopts the <strong>EQName</strong> (Extended QName) notation from [[XPATH-31]].
    </p>
    <dl>
        <dt>Prefixed QName (e.g., <code>atom:title</code>)</dt>
        <dd>The classic <code>prefix:local-name</code> syntax. Its use is supported but discouraged in favor of EQNames, as it relies on an external context to map the prefix to a namespace URI.</dd>
        
        <dt>EQName / URI-Qualified Name (e.g., <code>Q{http://www.w3.org/2005/Atom}title</code>)</dt>
        <dd>The <code>Q{namespace-uri}local-name</code> syntax. This is the <strong>recommended approach</strong> as it includes the full namespace URI directly within the expression, making queries self-contained and unambiguous.</dd>
    </dl>
    <p>
        Because RDF predicates are full URIs, using the EQName syntax is the most precise method for navigating RDF graphs.
    </p>
    <pre class="example">
// EQName syntax is unambiguous and recommended
Q{http://www.w3.org/2005/Atom}feed/Q{http://www.w3.org/2005/Atom}entry/title

// EQName used to query an RDF property
Q{http://xmlns.com/foaf/0.1/}Person/Q{http://xmlns.com/foaf/0.1/}knows

// Full URI used in a predicate value
*[rdf:type = &lt;http://xmlns.com/foaf/0.1/Person&gt;]
    </pre>
  </section>

  <section id="transforms">
    <h2>Format Transformations</h2>
    <p>
      The pipe operator (<code>|</code>) is used for transformations. As described in the <a href="#execution-models">Operating Models</a>, the first pipe in a <code>ResourceQuery</code> serves to load and parse a resource. Subsequent pipes transform the current selection, often by type-casting a <a>Leaf</a>'s value into a new <a>Node</a> structure, as defined in the <a href="#core-concepts">Core Principles</a>.
    </p>
    <div class="note">
      <h4>Note on Sequences</h4>
      <p>All transformations described below adhere to the Implicit Iteration principle. When the input is a <code>Sequence(T)</code>, the output will be a <code>Sequence(U)</code>, where the transformation <code>T → U</code> has been applied to each item.</p>
    </div>
    
    <h3>Data Serialization Formats</h3>
    <p>These transformations parse a string-based or binary <a href="#dfn-leaf">Leaf</a> or resource into a navigable <a>Node</a> structure.</p>
    <table>
        <thead>
            <tr><th>Format</th><th>Description</th><th>Type Signature</th><th>Reference</th></tr>
        </thead>
        <tbody>
            <tr><td><code>|xml</code></td><td>Extensible Markup Language.</td><td><code>(ResourceLocator | Leaf(String | Binary)) → Node(XML)</code></td><td><a href="#W3C-XML">W3C XML 1.0</a></td></tr>
            <tr><td><code>|exi</code></td><td>Efficient XML Interchange (binary XML).</td><td><code>(ResourceLocator | Leaf(Binary)) → Node(XML)</code></td><td><a href="#W3C-EXI">W3C EXI 1.0</a></td></tr>
            <tr><td><code>|json</code></td><td>JavaScript Object Notation.</td><td><code>(ResourceLocator | Leaf(String | Binary)) → Node(Object | Array)</code></td><td><a href="#RFC8259">RFC 8259</a></td></tr>
            <tr><td><code>|csv</code></td><td>Comma-Separated Values.</td><td><code>(ResourceLocator | Leaf(String | Binary)) → Node(Array)</code></td><td><a href="#RFC4180">RFC 4180</a></td></tr>
            <tr><td><code>|rdf</code></td><td>Resource Description Framework.</td><td><code>(ResourceLocator | Leaf(String | Binary)) → Node(Graph)</code></td><td><a href="#W3C-RDF11">W3C RDF 1.1</a></td></tr>
            <tr><td><code>|html</code></td><td>HyperText Markup Language.</td><td><code>(ResourceLocator | Leaf(String | Binary)) → Node(HTML)</code></td><td><a href="#WHATWG-HTML">WHATWG HTML</a></td></tr>
            <tr><td><code>|text</code></td><td>Plain text. Forces a binary leaf to be interpreted as a string.</td><td><code>(ResourceLocator | Leaf(Binary)) → Leaf(String)</code></td><td><a href="#RFC2046">RFC 2046</a></td></tr>
            <tr><td><code>|yaml</code></td><td>YAML Ain't Markup Language.</td><td><code>(ResourceLocator | Leaf(String | Binary)) → Node(Object | Array)</code></td><td><a href="#YAML-SPEC">YAML 1.2.2</a></td></tr>
            <tr><td><code>|toml</code></td><td>Tom's Obvious, Minimal Language.</td><td><code>(ResourceLocator | Leaf(String | Binary)) → Node(Object)</code></td><td><a href="#TOML-SPEC">TOML 1.0.0</a></td></tr>
        </tbody>
    </table>

    <h3>Filesystem Operations</h3>
    <p>This operator treats a local directory path as a navigable archive-like structure.</p>
    <table>
        <thead>
            <tr><th>Format</th><th>Description</th><th>Type Signature</th><th>Reference</th></tr>
        </thead>
        <tbody>
            <tr><td><code>|ls</code></td><td>Lists the contents of a local directory.</td><td><code>ResourceLocator(Directory) → Node(Archive)</code></td><td>N/A</td></tr>
        </tbody>
    </table>
    
    <h3>Decompression (<code>decomp:</code> prefix)</h3>
    <p>These transformations operate on a resource or a binary <a href="#dfn-leaf">Leaf</a>, decompressing it to expose a virtual filesystem of <a>Nodes</a> or a raw binary stream.</p>
    <table>
        <thead>
            <tr><th>Format</th><th>Description</th><th>Type Signature</th><th>Reference</th></tr>
        </thead>
        <tbody>
            <tr><td><code>|decomp:zip</code></td><td>ZIP file format.</td><td><code>(ResourceLocator | Leaf(Binary)) → Node(Archive)</code></td><td><a href="#PKWARE-ZIP">PKWARE ZIP</a></td></tr>
            <tr><td><code>|decomp:tar</code></td><td>Tape Archive.</td><td><code>(ResourceLocator | Leaf(Binary)) → Node(Archive)</code></td><td><a href="#POSIX-TAR">POSIX.1-2017</a></td></tr>
            <tr><td><code>|decomp:gz</code></td><td>Gzip compression.</td><td><code>(ResourceLocator | Leaf(Binary)) → Leaf(Binary)</code></td><td><a href="#RFC1952">RFC 1952</a></td></tr>
            <tr><td><code>|decomp:7z</code></td><td>7z archive format.</td><td><code>(ResourceLocator | Leaf(Binary)) → Node(Archive)</code></td><td><a href="#7Z-FORMAT">7-Zip Format</a></td></tr>
            <tr><td><code>|decomp:rar</code></td><td>Roshal Archive.</td><td><code>(ResourceLocator | Leaf(Binary)) → Node(Archive)</code></td><td>N/A</td></tr>
            <tr><td><code>|decomp:xz</code></td><td>XZ compression.</td><td><code>(ResourceLocator | Leaf(Binary)) → Leaf(Binary)</code></td><td><a href="#XZ-SPEC">XZ Format</a></td></tr>
            <tr><td><code>|decomp:bz2</code></td><td>Bzip2 compression.</td><td><code>(ResourceLocator | Leaf(Binary)) → Leaf(Binary)</code></td><td><a href="#BZIP2-SPEC">Bzip2 Format</a></td></tr>
            <tr><td><code>|decomp:zstd</code></td><td>Zstandard compression.</td><td><code>(ResourceLocator | Leaf(Binary)) → Leaf(Binary)</code></td><td><a href="#RFC8878">RFC 8878</a></td></tr>
            <tr><td><code>|decomp:brotli</code></td><td>Brotli compression.</td><td><code>(ResourceLocator | Leaf(Binary)) → Leaf(Binary)</code></td><td><a href="#RFC7932">RFC 7932</a></td></tr>
        </tbody>
    </table>

    <h3>Decoding (<code>decode:</code> prefix)</h3>
    <p>These are intermediate transformations that type-cast a <a href="#dfn-leaf">Leaf</a>'s value.</p>
    <table>
        <thead>
            <tr><th>Format</th><th>Description</th><th>Type Signature</th><th>Reference</th></tr>
        </thead>
        <tbody>
            <tr><td><code>|decode:base64</code></td><td>Base64 decoding.</td><td><code>Leaf(String) → Leaf(Binary)</code></td><td><a href="#RFC4648">RFC 4648</a></td></tr>
            <tr><td><code>|decode:hex</code></td><td>Hexadecimal decoding.</td><td><code>Leaf(String) → Leaf(Binary)</code></td><td><a href="#RFC4648">RFC 4648</a></td></tr>
            <tr><td><code>|decode:url</code></td><td>Percent-decoding.</td><td><code>Leaf(String) → Leaf(String)</code></td><td><a href="#RFC3986">RFC 3986</a></td></tr>
            <tr><td><code>|decode:html-entities</code></td><td>Decodes HTML/XML character entities.</td><td><code>Leaf(String) → Leaf(String)</code></td><td><a href="#WHATWG-HTML">WHATWG HTML</a></td></tr>
            <tr><td><code>|decode:json-string</code></td><td>Un-escapes a string that was itself encoded as a JSON string literal.</td><td><code>Leaf(String) → Leaf(String)</code></td><td><a href="#RFC8259">RFC 8259</a></td></tr>
            <tr><td><code>|decode:punycode</code></td><td>Decodes Punycode strings (IDN).</td><td><code>Leaf(String) → Leaf(String)</code></td><td><a href="#RFC3492">RFC 3492</a></td></tr>
            <tr><td><code>|decode:quoted-printable</code></td><td>Decodes Quoted-Printable (MIME) content.</td><td><code>Leaf(String) → Leaf(String)</code></td><td><a href="#RFC2045">RFC 2045</a></td></tr>
        </tbody>
    </table>
  </section>
  
  <section id="predicates">
    <h2>Predicates (Filters)</h2>
    <p>
      Predicates, placed between square brackets <code>[...]</code>, are used to filter sets of <a>nodes</a>.
    </p>
    <pre class="example">
// Equality test
[@attr = "value"]

// Inequality test
[@attr != "value"]

// Numeric or alphabetical comparisons
[@attr > 100]

// Regular expression matching
[@attr ~ "^pattern.*$"]

// Negation and logical operators
[!expr]
[expr1 & expr2]  // AND
[expr1 | expr2]  // OR
    </pre>
    
    <section id="positional-predicates">
      <h3>Positional Predicates</h3>
      <p>These functions are used within a predicate to filter based on position in a sequence.</p>
        <table>
            <thead>
                <tr><th>Function</th><th>Description</th><th>Type Signature</th></tr>
            </thead>
            <tbody>
                <tr><td><code>position()</code></td><td>Returns the 1-based position of the current item in its sequence. `[n]` is a shorthand for `[position()=n]`.</td><td><code>() → Leaf(Number)</code></td></tr>
                <tr><td><code>last()</code></td><td>Returns the total number of items in the current sequence.</td><td><code>() → Leaf(Number)</code></td></tr>
            </tbody>
        </table>
    </section>
  </section>
  
  <section id="functions">
    <h2>Built-in Functions</h2>
    <p>Built-in functions are called without a namespace prefix (e.g., <code>text()</code>). Custom functions provided by a <a href="#host-language-integration">host language</a> <em class="rfc2119">MUST</em> use a namespace prefix (e.g., <code>myfuncs:my_func()</code>).</p>
    
    <section id="structural-functions">
      <h3>Structural Navigation</h3>
      <p>These functions manipulate or query the structure of the data model.</p>
      <table>
        <thead>
            <tr><th>Function</th><th>Description</th><th>Type Signature</th></tr>
        </thead>
        <tbody>
            <tr><td><code>outer(selector, n)</code></td><td>Navigates upwards <code>n</code> levels, jumping only over <a>nodes</a> that match the selector.</td><td><code>(Node, String, Number) → Sequence(Node)</code></td></tr>
            <tr><td><code>inner(selector)</code></td><td>Navigates to the terminal elements matching the selector within the current context.</td><td><code>(Node, String) → Sequence(Node)</code></td></tr>
        </tbody>
      </table>
    </section>
    
    <section id="filtering-functions">
      <h3>Hierarchical Filtering</h3>
      <p>These functions operate on sequences of nodes to filter them based on their hierarchical relationships.</p>
      <table>
        <thead>
            <tr><th>Function</th><th>Description</th><th>Type Signature</th></tr>
        </thead>
        <tbody>
            <tr><td><code>outermost(nodes)</code></td><td>From a set of <a>nodes</a>, keeps only those that are not contained within other <a>nodes</a> in the set.</td><td><code>(Sequence(Node)) → Sequence(Node)</code></td></tr>
            <tr><td><code>innermost(nodes)</code></td><td>From a set of <a>nodes</a>, keeps only those that do not contain any other <a>nodes</a> from the set.</td><td><code>(Sequence(Node)) → Sequence(Node)</code></td></tr>
        </tbody>
      </table>
    </section>
    
    <section id="utility-functions">
      <h3>Utility Functions</h3>
      <p>These functions provide general utility for inspection and logic within queries.</p>
      <table>
        <thead>
            <tr><th>Function</th><th>Description</th><th>Type Signature</th></tr>
        </thead>
        <tbody>
            <tr><td><code>only(elements)</code></td><td>Tests if the context contains only the specified elements.</td><td><code>(Node, Sequence(Node)) → Leaf(Boolean)</code></td></tr>
            <tr><td><code>text()</code></td><td>Returns the text content of a <a>node</a>.</td><td><code>(Node) → Leaf(String)</code></td></tr>
            <tr><td><code>lang()</code></td><td>When used on a literal <a>leaf</a>, returns its language tag as a string.</td><td><code>(Leaf) → Leaf(String)</code></td></tr>
            <tr><td><code>count()</code></td><td>Returns the number of elements in a selection.</td><td><code>(Sequence(T)) → Leaf(Number)</code></td></tr>
            <tr><td><code>type()</code></td><td>Returns the <a data-lt="Node">node's</a> type as a string (e.g., "element", "object").</td><td><code>(Node) → Leaf(String)</code></td></tr>
            <tr><td><code>not(expr)</code></td><td>Negation of a predicate expression.</td><td><code>(Leaf(Boolean)) → Leaf(Boolean)</code></td></tr>
        </tbody>
      </table>
    </section>
  </section>
  
  <section id="examples">
    <h2>Examples</h2>
    <p>The following examples illustrate the two operating models and advanced features.</p>
    
    <section id="ex-basic">
        <h3>Basic Examples</h3>
        <pre class="example nohighlight">
// In-Memory: Get an attribute from an XML node
doc/book/@isbn

// In-Memory: Get the name from the first object in a JSON array
users[1]/@name

// Resource Loading: Get a column from a specific row in a CSV file
data.csv|csv/*[@id="ABC"]/@name

// Resource Loading: Navigate into a ZIP file to get an XML element
http://example.com/data.zip|decomp:zip/docs/report.xml|xml//title
        </pre>
    </section>
    
    <section id="ex-advanced">
        <h3>Advanced Examples</h3>
        <pre class="example nohighlight">
// Recursive Parsing: A leaf's value is piped into a new parser
// Gets the 2nd tag from a comma-separated string within a CSV cell
users.csv|csv/*[1]/@tags|csv/*[1]/@*[2]

// API Chaining: A payload contains gzipped XML data
// The query decodes, decompresses, and parses the data in one pipeline
api/data|json/@payload|decode:base64|decomp:gz|xml//important

// Sequence Processing: Get all unique, sorted authors from a set of files
"data/*.xml"|xml//author/text()||distinct|order-by(.)
        </pre>
    </section>
  </section>
  
  <section id="references" class="appendix">
    <h2>References</h2>
    <dl>
        <dt id="RFC2119">RFC 2119</dt>
        <dd><a href="https://www.rfc-editor.org/info/rfc2119">Key words for use in RFCs to Indicate Requirement Levels</a>, S. Bradner, IETF, March 1997.</dd>
        <dt id="RFC8174">RFC 8174</dt>
        <dd><a href="https://www.rfc-editor.org/info/rfc8174">Ambiguity of Uppercase vs Lowercase in RFC 2119 Key Words</a>, B. Leiba, IETF, May 2017.</dd>
        <dt id="ISO-IEC-14977">ISO/IEC 14977:1996</dt>
        <dd><a href="https://www.iso.org/standard/26153.html">Information technology — Syntactic metalanguage — Extended BNF</a>.</dd>
        <dt id="W3C-XML">W3C XML 1.0</dt>
        <dd><a href="https://www.w3.org/TR/xml/">Extensible Markup Language (XML) 1.0 (Fifth Edition)</a>, T. Bray, et al., W3C Recommendation, 26 November 2008.</dd>
        <dt id="XML-INFOSET">XML-INFOSET</dt>
        <dd><a href="https://www.w3.org/TR/xml-infoset/">XML Information Set (Second Edition)</a>, J. Cowan, et al., W3C Recommendation, 04 February 2004.</dd>
        <dt id="XML-NAMES">XML-NAMES</dt>
        <dd><a href="https://www.w3.org/TR/xml-names/">Namespaces in XML 1.0 (Third Edition)</a>, T. Bray, et al., W3C Recommendation, 8 December 2009.</dd>
        <dt id="XPATH-31">XPATH 3.1</dt>
        <dd><a href="https://www.w3.org/TR/xpath-31/">XML Path Language (XPath) 3.1</a>, J. Robie, et al., W3C Recommendation, 21 March 2017.</dd>
        <dt id="W3C-EXI">W3C EXI 1.0</dt>
        <dd><a href="https://www.w3.org/TR/exi/">Efficient XML Interchange (EXI) Format 1.0 (Second Edition)</a>, J. Schneider, et al., W3C Recommendation, 15 February 2011.</dd>
        <dt id="RFC8259">RFC 8259</dt>
        <dd><a href="https://www.rfc-editor.org/info/rfc8259">The JavaScript Object Notation (JSON) Data Interchange Format</a>, T. Bray, Ed., IETF, December 2017.</dd>
        <dt id="RFC4180">RFC 4180</dt>
        <dd><a href="https://www.rfc-editor.org/info/rfc4180">Common Format and MIME Type for Comma-Separated Values (CSV) Files</a>, Y. Shafranovich, IETF, October 2005.</dd>
        <dt id="W3C-RDF11">W3C RDF 1.1</dt>
        <dd><a href="https://www.w3.org/TR/rdf11-concepts/">RDF 1.1 Concepts and Abstract Syntax</a>, R. Cyganiak, et al., W3C Recommendation, 25 February 2014.</dd>
        <dt id="WHATWG-HTML">WHATWG HTML</dt>
        <dd><a href="https://html.spec.whatwg.org/multipage/">HTML Living Standard</a>, WHATWG.</dd>
        <dt id="RFC2046">RFC 2046</dt>
        <dd><a href="https://www.rfc-editor.org/info/rfc2046">Multipurpose Internet Mail Extensions (MIME) Part Two: Media Types</a>, N. Freed, et al., IETF, November 1996.</dd>
        <dt id="YAML-SPEC">YAML 1.2.2</dt>
        <dd><a href="https://yaml.org/spec/1.2.2/">YAML Ain’t Markup Language (YAML™) Version 1.2.2</a>, O. Ben-Kiki, et al., 1 October 2021.</dd>
        <dt id="TOML-SPEC">TOML 1.0.0</dt>
        <dd><a href="https://toml.io/v1.0.0/">Tom's Obvious, Minimal Language (TOML) v1.0.0</a>.</dd>
        <dt id="PKWARE-ZIP">PKWARE ZIP</dt>
        <dd><a href="https://pkware.cachefly.net/webdocs/casestudies/APPNOTE.TXT">.ZIP File Format Specification</a>, PKWARE Inc.</dd>
        <dt id="POSIX-TAR">POSIX.1-2017</dt>
        <dd><a href="https://pubs.opengroup.org/onlinepubs/9699919799/utilities/pax.html#tag_20_92_13_06">tar - tape archive utility</a>, IEEE Std 1003.1-2017.</dd>
        <dt id="RFC1952">RFC 1952</dt>
        <dd><a href="https://www.rfc-editor.org/info/rfc1952">GZIP file format specification version 4.3</a>, P. Deutsch, IETF, May 1996.</dd>
        <dt id="7Z-FORMAT">7-Zip Format</dt>
        <dd><a href="https://www.7-zip.org/7z.html">7z format</a>, Igor Pavlov.</dd>
        <dt id="XZ-SPEC">XZ Format</dt>
        <dd><a href="https://tukaani.org/xz/xz-file-format.txt">The .xz File Format</a>, Tukaani.</dd>
        <dt id="BZIP2-SPEC">Bzip2 Format</dt>
        <dd><a href="https://github.com/dsnet/compress/blob/master/doc/bzip2-format.pdf">BZIP2 Format Specification</a>, J. Seward.</dd>
        <dt id="RFC8878">RFC 8878</dt>
        <dd><a href="https://www.rfc-editor.org/info/rfc8878">Zstandard Compression Algorithm</a>, Y. Collet & M. Kucherawy, Ed., IETF, February 2021.</dd>
        <dt id="RFC7932">RFC 7932</dt>
        <dd><a href="https://www.rfc-editor.org/info/rfc7932">Brotli Compressed Data Format</a>, J. Alakuijala & Z. Szabadka, IETF, July 2016.</dd>
        <dt id="RFC4648">RFC 4648</dt>
        <dd><a href="https://www.rfc-editor.org/info/rfc4648">The Base16, Base32, and Base64 Data Encodings</a>, S. Josefsson, IETF, October 2006.</dd>
        <dt id="RFC3986">RFC 3986</dt>
        <dd><a href="https://www.rfc-editor.org/info/rfc3986">Uniform Resource Identifier (URI): Generic Syntax</a>, T. Berners-Lee, et al., IETF, January 2005.</dd>
        <dt id="RFC3492">RFC 3492</dt>
        <dd><a href="https://www.rfc-editor.org/info/rfc3492">Punycode: A Bootstring encoding of Unicode for Internationalized Domain Names in Applications (IDNA)</a>, A. Costello, IETF, March 2003.</dd>
        <dt id="RFC2045">RFC 2045</dt>
        <dd><a href="https://www.rfc-editor.org/info/rfc2045">Multipurpose Internet Mail Extensions (MIME) Part One: Format of Internet Message Bodies</a>, N. Freed & N. Borenstein, IETF, November 1996.</dd>
    </dl>
  </section>

  <section id="conversion-paths" class="appendix">
    <h2>Common Transformation Paths</h2>
    <p>This appendix summarizes common data conversion pathways, showing the UNL operators used to transform an input representation into a desired output structure, as defined in the <a href="#data-mapping">Data Model Mapping</a> appendix.</p>
    
    <section>
        <h3>Producing a Navigable Node (e.g., XML, JSON)</h3>
        <dl>
            <dt>From a ResourceLocator</dt>
            <dd><code>"my_data.json"|json/...</code></dd>
            <dt>From a Leaf(String)</dt>
            <dd><code>...@string_leaf|xml/...</code></dd>
            <dt>From a Leaf(Binary)</dt>
            <dd><code>...@binary_leaf|json/...</code> (Parser auto-detects encoding)</dd>
            <dd><code>...@gzipped_json_leaf|decomp:gz|json/...</code> (Decompress then parse)</dd>
        </dl>
    </section>
    
    <section>
        <h3>Producing a Navigable Archive Node</h3>
        <dl>
            <dt>From a ResourceLocator</dt>
            <dd><code>"my_files.zip"|decomp:zip/...</code></dd>
            <dt>From a Leaf(Binary)</dt>
            <dd><code>...@binary_zip_leaf|decomp:zip/...</code></dd>
        </dl>
    </section>
    
    <section>
        <h3>Producing a Leaf(String)</h3>
        <dl>
            <dt>From a ResourceLocator</dt>
            <dd><code>"my_file.txt"|text</code></dd>
            <dt>From a Leaf(Binary)</dt>
            <dd><code>...@binary_leaf|text</code></dd>
            <dt>From a Node</dt>
            <dd><code>.../my_node|text</code> (Serializes the node to its default text representation, e.g., outer XML)</dd>
        </dl>
    </section>

    <section>
        <h3>Producing a Leaf(Binary)</h3>
        <dl>
            <dt>From a ResourceLocator</dt>
            <dd>This is the default interpretation of a resource locator before any pipe is applied.</dd>
            <dt>From a Leaf(String)</dt>
            <dd><code>...@string_leaf|decode:base64</code></dd>
            <dt>From a Node</dt>
            <dd><code>.../my_node|exi</code> (Serializes an XML node to binary EXI format)</dd>
        </dl>
    </section>
  </section>
  
  <section id="ebnf-grammar" class="appendix">
    <h2>EBNF Grammar for UNL v1.0</h2>
    <p>This appendix provides a non-normative grammar for the Unified Navigation Language, with a syntax conforming to the EBNF standard [[ISO-IEC-14977]].</p>
    <pre class="grammar">
(* A full query can have an optional, final aggregation stage *)
UNLQuery           ::= ( ResourceQuery | InMemoryQuery ) ( '||' AggregationPath )?

(* Form 1: Starts with a resource, requires a parsing transformation *)
ResourceQuery      ::= ResourceLocator StreamingPipe ( StreamingPipe )*

(* Form 2: Starts with a path, operates on a pre-existing context *)
InMemoryQuery      ::= Path ( StreamingPipe )*

StreamingPipe      ::= '|' ( DataFormat | FilesystemOp | DecompTransform | DecodeTransform | StreamingAggregate )
AggregationPath    ::= BlockingAggregate ( '|' BlockingAggregate )*

Path               ::= Step ( ( '/' | '?' ) Step )*
Step               ::= ( PrimaryStep | Axis ) Predicate*

PrimaryStep        ::= NameTest | Wildcard | LeafAccess | IdAccess | '.' | '(' Path ')'

(* A NameTest can be a standard EQName or a quoted literal string *)
NameTest           ::= EQName | Literal
LeafAccess         ::= '@' ( EQName | '*' | Literal )

EQName             ::= QName | URIQualifiedName
QName              ::= ( NCName ':' )? NCName
URIQualifiedName   ::= 'Q{' URILiteral '}' NCName

Wildcard           ::= '*' | '**' | '?'
IdAccess           ::= '#' NCName
Axis               ::= '..' | '..' Integer | '...' | '+' | '-' | '~' | '~~'

Predicate          ::= '[' FilterExpression ']'

FilterExpression   ::= OrExpression
OrExpression       ::= AndExpression ( '|' AndExpression )*
AndExpression      ::= EqualityExpression ( '&amp;' EqualityExpression )*
EqualityExpression ::= RelationalExpression ( ( '=' | '!=' ) RelationalExpression )?
RelationalExpression ::= PrimaryFilterExpr ( ( '&lt;' | '&gt;' | '&lt;=' | '&gt;=' | '~' ) PrimaryFilterExpr )*

PrimaryFilterExpr  ::= Literal | Variable | FunctionCall | Path | LeafAccess | '!' FilterExpression | '(' FilterExpression ')' | Integer

Variable           ::= '$' NCName
FunctionCall       ::= EQName '(' ( FilterExpression ( ',' FilterExpression )* )? ')'

(* Operator Definitions *)
DataFormat         ::= 'xml' | 'exi' | 'json' | 'csv' | 'rdf' | 'html' | 'text' | 'yaml' | 'toml'
FilesystemOp       ::= 'ls'
DecompTransform    ::= 'decomp:' ( 'zip' | 'tar' | 'gz' | '7z' | 'gzip' | 'rar' | 'xz' | 'bz2' | 'zstd' | 'brotli' )
DecodeTransform    ::= 'decode:' ( 'base64' | 'hex' | 'url' | 'html-entities' | 'json-string' | 'punycode' | 'quoted-printable' )
StreamingAggregate ::= 'count' | 'sum' | 'avg' | 'min' | 'max' | 'head' '(' Integer ')' | 'tail' '(' Integer ')'
BlockingAggregate  ::= 'distinct' | 'order-by' '(' Path ')' | 'group-by' '(' Path ')'

(* Lexical Definitions (Informal) *)
ResourceLocator    ::= (* A literal string representing a URI or file path. It uses standard '/' separators and does not support UNL operators like '?' or '@'. UNL navigation begins after the first pipe. *)
URILiteral         ::= (* A string representing a valid URI, conforming to RFC3986 *)
NCName             ::= (* A Non-Colonized Name, as defined in [[XML-NAMES]]. It must not contain ':' and should be compliant with the full Unicode character set allowed by that standard. *)
Integer            ::= [0-9]+
Literal            ::= '"' ( [^"\\] | '\\' . )* '"' | "'" ( [^'\\] | '\\' . )* "'"
    </pre>
  </section>

  <section id="data-mapping" class="appendix">
    <h2>Data Model Mapping</h2>
    <p>
        This section defines how UNL's abstract concepts of <a>Node</a> and <a>Leaf</a> are mapped onto the concrete structures of each major supported format. UNL is a <strong>1-based</strong> language, following the convention of XPath for all positional indexing.
    </p>

    <section>
        <h3>UNL's Conceptual Data Types</h3>
        <p>To describe transformations accurately, UNL uses a set of conceptual data types.</p>
        <dl>
            <dt><code>Node</code></dt>
            <dd>The base type for any navigable structure. It has several specializations:
                <ul>
                    <li><code>Node(Object)</code>: An unordered collection of key-value pairs, similar to a JSON object.</li>
                    <li><code>Node(Array)</code>: An ordered collection of other Nodes or Leaves.</li>
                    <li><code>Node(XML | HTML)</code>: A structure compliant with the [[XML-INFOSET]].</li>
                    <li><code>Node(Graph)</code>: A structure representing RDF triples.</li>
                    <li><code>Node(Archive)</code>: A virtual filesystem root, containing file and directory nodes. This is produced by <code>|decomp:</code> operators and <code>|ls</code>.</li>
                    <li><code>Node(Group)</code>: A special node produced by the <code>group-by</code> operator, containing a key and a sequence of items.</li>
                </ul>
            </dd>
            <dt><code>Leaf</code></dt>
            <dd>The base type for any terminal, atomic value. It has several specializations:
                <ul>
                    <li><code>Leaf(String)</code>: A Unicode string. This is the primary type for textual data.</li>
                    <li><code>Leaf(Binary)</code>: A sequence of raw bytes. This is the primary type for non-textual data. Text-based parsers like <code>|xml</code> can also consume a <code>Leaf(Binary)</code> directly by auto-detecting character encoding. The <code>|text</code> operator provides an explicit way to interpret binary data as text.</li>
                    <li><code>Leaf(Number)</code>, <code>Leaf(Boolean)</code>, <code>Leaf(Null)</code>: Primitive data types.</li>
                </ul>
            </dd>
            <dt><code>Sequence(T)</code></dt>
            <dd>An ordered collection of items of type T, for example a <code>Sequence(Node)</code>.</dd>
            <dt><code>ResourceLocator</code></dt>
            <dd>A string that represents a URI or a local file path, used as the initial input for a <code>ResourceQuery</code>.</dd>
        </dl>
    </section>

    <h3>XML</h3>
    <p>The <code>|xml</code> transformation is a <strong>strict</strong> parser that produces a navigable structure compliant with the [[XML-INFOSET]]. It will fail on malformed documents.</p>
    <dl>
        <dt><a>Node</a></dt>
        <dd>An XML Element.</dd>
        <dt><a>Leaf</a></dt>
        <dd>An XML Attribute, or a Text node.</dd>
    </dl>
    
    <h3>HTML</h3>
    <p>The <code>|html</code> transformation is a <strong>lenient</strong> parser that mimics browser behavior. It will attempt to fix errors and will always produce a navigable structure compliant with the [[XML-INFOSET]].</p>
    <div class="note">
        <p>From the perspective of subsequent UNL path navigation, a structure parsed from HTML is indistinguishable from one parsed from well-formed XML (like XHTML). The UNL engine operates on the unified Infoset model.</p>
    </div>

    <h3>JSON</h3>
    <dl>
        <dt><a>Node</a></dt>
        <dd>A JSON Object (<code>{}</code>) or a JSON Array (<code>[]</code>).</dd>
        <dt><a>Leaf</a></dt>
        <dd>A value within an object or array that is a String, Number, Boolean, or Null.</dd>
    </dl>
    
    <h3>CSV</h3>
    <p>The <code>|csv</code> transformation parses data into an array of nodes. All indexing is 1-based.</p>
    <dl>
        <dt><a>Node</a></dt>
        <dd>The result of the <code>|csv</code> transformation is a single Array Node. Each record (line) in the CSV is mapped to a child Node within this array.</dd>
        <dt><a>Leaf</a></dt>
        <dd>
            An individual cell value within a row. A row's leaves form an ordered collection that can be accessed in two equivalent ways:
            <ul>
                <li><strong>By Name (if header exists):</strong> Using <code>/@name</code>. This is the most readable method.</li>
                <li><strong>By Position (always available):</strong> Using <code>/@*[n]</code>, where <code>n</code> is a 1-based integer. <code>@*</code> selects all leaves, and <code>[n]</code> filters for the n-th position.</li>
            </ul>
        </dd>
    </dl>
    <pre class="example nohighlight">
// Example 1: CSV with header (in "users.csv")
id,name,role,tags
1,Alice,admin,"a,b,c"

// Query 1: Get the 'role' leaf from rows where 'id' leaf is "1"
users.csv|csv/*[@id="1"]/@role          // Returns leaf "admin"

// Query 2: Get the 2nd tag from Alice's record. This requires a nested parse.
users.csv|csv/*[1]/@tags|csv/*[1]/@*[2]    // Returns leaf "b"

// Example 2: Headerless CSV (in "logs.csv")
1687354800,ERROR,auth_service

// Get the 2nd column of the 1st record
logs.csv|csv/*[1]/@*[2]                   // Returns leaf "ERROR"
    </pre>

    <h3>RDF</h3>
    <p>UNL navigates an RDF graph by following predicates (properties).</p>
    <dl>
        <dt><a>Node</a></dt>
        <dd>A resource identified by a URI or a Blank Node, when it acts as a subject or object of a triple.</dd>
        <dt><a>Leaf</a></dt>
        <dd>A Literal value (e.g., a string, number, or date) that is the object of a triple. Literals are accessed via the <code>@</code> prefix followed by the EQName of the predicate.</dd>
    </dl>
    <pre class="example">
// --- Data (in Turtle syntax) ---
@prefix : &lt;http://example.org/ns#&gt; .
@prefix foaf: &lt;http://xmlns.com/foaf/0.1/&gt; .
@prefix rdfs: &lt;http://www.w3.org/2000/01/rdf-schema#&gt; .

:book1 a :Book ;
    rdfs:label "UNL Specification"@en ;
    rdfs:label "Spécification UNL"@fr ;
    foaf:maker :person1 .

:person1 a foaf:Person ;
    foaf:name "John Doe" .
    
// --- UNL Queries (In-Memory Mode) ---
// Note the use of @ followed by the full EQName of the property
:book1/foaf:maker/@foaf:name
// Returns leaf "John Doe"

// Filter leaves based on their language tag using the lang() function
:book1/@rdfs:label[lang()="fr"]
// Returns leaf "Spécification UNL"
    </pre>

    <h3>Archives and Filesystems</h3>
    <p>Archives (via <code>decomp:</code>) and local filesystems (via <code>|ls</code>) are treated as a virtual filesystem. Both files and directories are modeled as <a>Nodes</a> to allow querying their metadata.</p>
    <dl>
        <dt><a>Node</a></dt>
        <dd>A directory or a file. Directory nodes can contain other nodes. File nodes are terminal for path navigation but expose metadata leaves.</dd>
        <dt><a>Leaf</a></dt>
        <dd>
            Metadata about a file or directory node. When a file <a>node</a> is piped to another transformation, its raw content is used as the input. A standard set of metadata leaves is defined:
            <ul>
                <li><code>@name</code>: The name of the file or directory.</li>
                <li><code>@size</code>: The uncompressed size in bytes (files only).</li>
                <li><code>@compressed_size</code>: The compressed size in bytes (files only).</li>
                <li><code>@modified_date</code>: The modification timestamp.</li>
                <li><code>@is_dir</code>: A boolean that is true if the node is a directory.</li>
            </ul>
        </dd>
    </dl>
     <pre class="example nohighlight">
// Example 1: List contents of a local directory
"./src"|ls/*

// Example 2: Get the size of a specific file in a ZIP archive.
my_archive.zip|decomp:zip/docs/report.xml/@size

// Example 3: Filter files by metadata from a local directory, then pipe their content.
"./src"|ls/*[@is_dir=false() and @name ~ "\.js$"]|count
    </pre>

  </section>

</body>
</html>
