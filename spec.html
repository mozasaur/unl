<!DOCTYPE html>
<html lang="en">
<head>
  <title>UNL - Unified Navigation Language - Final Specification v1.0</title>
  <meta charset="UTF-8">
  <script src="https://www.w3.org/Tools/respec/respec-w3c" class="remove"></script>
  
  <script class="remove">
    var respecConfig = {
      specStatus: "unofficial",
      shortName: "unl-spec-en",
      subtitle: "Final Specification v1.0",
      editors: [
        { name: "Specification Provided by User" }
      ],
      github: "https://github.com/example/unl-spec",
      issueBase: "https://github.com/example/unl-spec/issues/",
    };
  </script>
</head>
<body>

  <section id="abstract">
    <h2>Abstract</h2>
    <p>
      The Unified Navigation Language (UNL) provides a single, coherent syntax to query, navigate, and transform data across multiple structured formats such as XML, JSON, CSV, and RDF. It draws inspiration from proven concepts like XPath and CSS selectors while introducing innovative features like optional navigation, built-in format transformation, and advanced structural navigation functions. The goal is to offer a single, intuitive language for all data formats.
    </p>
  </section>

  <section id="sotd">
    </section>
  
  <section id="intro">
    <h2>Introduction</h2>
    <p>
      In an increasingly heterogeneous data ecosystem, developers must master multiple query languages (XPath for XML, JSONPath for JSON, SPARQL for RDF, etc.). UNL was designed to eliminate this complexity by offering a unified abstraction layer.
    </p>
    <p>
      UNL's key innovations are:
    </p>
    <ul>
      <li><strong>Optional Navigation <code>?</code>:</strong> A unique syntax to elegantly handle variable or incomplete data structures.</li>
      <li><strong>Node/Leaf Distinction (<code>@</code>):</strong> Provides fundamental semantic clarity by distinguishing between navigable containers and final values.</li>
      <li><strong>Advanced Structural Navigation (<code>outer()</code>):</strong> Enables complex, type-based navigation jumps that are difficult to achieve with other languages.</li>
      <li><strong>Fluid Transformations (<code>|format</code>):</strong> The pipe operator allows for on-the-fly data conversion within a single navigation expression.</li>
      <li><strong>Native URI and Namespace Support:</strong> Full integration with semantic web standards (RDF, XML).</li>
      <li><strong>Unified Syntax:</strong> One language to rule all your formats.</li>
    </ul>
    <h3>Design Principles</h3>
    <ul>
      <li><strong>LALR(1) Parsable:</strong> The grammar is designed to be unambiguous and easily parsable.</li>
      <li><strong>Extensible:</strong> The system can incorporate new formats without changing the core parser.</li>
      <li><strong>Compatible:</strong> It is inspired by the best ideas from XPath and CSS without creating conflicts.</li>
      <li><strong>Intuitive:</strong> The syntax is designed to be read naturally.</li>
    </ul>
  </section>

  <section id="core-concepts">
    <h2>Fundamental Principle: Nodes and Leaves</h2>
    <p>
      UNL is based on a simple yet powerful distinction.
    </p>
    <dl>
      <dt><dfn>Leaf</dfn> (with <code>@</code>)</dt>
      <dd>Represents a final, non-navigable atomic value. It is the endpoint of a navigation path. Examples: a string, a number, a boolean value.</dd>
      <dt><dfn>Node</dfn> (without <code>@</code>)</dt>
      <dd>Represents a navigable structure that contains other nodes or leaves. Examples: an XML element, a JSON object, a CSV row.</dd>
    </dl>
  </section>
  
  <section id="syntax">
    <h2>Navigation Syntax</h2>
    
    <section id="nav-base">
      <h3>Base Navigation</h3>
      <table>
        <thead>
          <tr><th>Operator</th><th>Description</th></tr>
        </thead>
        <tbody>
          <tr><td><code>/</code></td><td>Mandatory navigation to a child. Must exist.</td></tr>
          <tr><td><code>?</code></td><td>Optional navigation between nodes. Allows chaining paths that may not exist (<code>a?b</code> is equivalent to <code>a</code> or <code>a/b</code>).</td></tr>
          <tr><td><code>?</code> (wildcard)</td><td>Single wildcard when used alone. Represents any single child (<code>a/?/c</code>).</td></tr>
          <tr><td><code>*</code></td><td>Multiple wildcard. Represents all direct children.</td></tr>
          <tr><td><code>**</code></td><td>Descendant wildcard. Represents all descendants at any level.</td></tr>
          <tr><td><code>.</code></td><td>Represents the current node.</td></tr>
          <tr><td><code>@name</code></td><td>Accesses a <a href="#dfn-leaf">leaf</a> (atomic value) named "name".</td></tr>
          <tr><td><code>#id</code></td><td>Direct access to a node by its ID or URI.</td></tr>
        </tbody>
      </table>
    </section>
    
    <section id="nav-vertical">
      <h3>Vertical Navigation (Ancestors)</h3>
      <table>
        <thead>
          <tr><th>Operator</th><th>Description</th></tr>
        </thead>
        <tbody>
          <tr><td><code>..</code></td><td>Direct parent.</td></tr>
          <tr><td><code>..n</code></td><td>Nth ancestor (e.g., <code>..2</code> for the grandparent).</td></tr>
          <tr><td><code>...</code></td><td>All ancestors up to the root.</td></tr>
        </tbody>
      </table>
    </section>
    
    <section id="nav-lateral">
      <h3>Lateral Navigation (Siblings)</h3>
      <table>
        <thead>
          <tr><th>Operator</th><th>Description</th></tr>
        </thead>
        <tbody>
          <tr><td><code>+</code></td><td>The immediate following-sibling.</td></tr>
          <tr><td><code>-</code></td><td>The immediate preceding-sibling.</td></tr>
          <tr><td><code>~</code></td><td>All following-siblings.</td></tr>
          <tr><td><code>~~</code></td><td>All preceding-siblings.</td></tr>
        </tbody>
      </table>
    </section>
  </section>

  <section id="transforms">
    <h2>Format Transformations</h2>
    <p>
      The pipe operator (<code>|</code>) is used for transformations. For clarity and future extensibility, transformations are namespaced based on their category. Data serialization formats are used directly, while operations like decompression and decoding require a prefix.
    </p>
    
    <h3>Data Serialization Formats</h3>
    <p>Used directly without a prefix.</p>
    <table>
        <thead>
            <tr><th>Format</th><th>Description</th><th>Reference</th></tr>
        </thead>
        <tbody>
            <tr><td><code>|xml</code></td><td>Extensible Markup Language, a text-based format for representing structured data.</td><td><a href="#W3C-XML">W3C XML 1.0</a></td></tr>
            <tr><td><code>|exi</code></td><td>Efficient XML Interchange, a binary compact representation for XML.</td><td><a href="#W3C-EXI">W3C EXI 1.0</a></td></tr>
            <tr><td><code>|json</code></td><td>JavaScript Object Notation, a lightweight data-interchange format.</td><td><a href="#RFC8259">RFC 8259</a></td></tr>
            <tr><td><code>|csv</code></td><td>Comma-Separated Values, a plain text format for tabular data.</td><td><a href="#RFC4180">RFC 4180</a></td></tr>
            <tr><td><code>|rdf</code></td><td>Resource Description Framework, a framework for representing information in the Web. Handled as RDF/XML or Turtle.</td><td><a href="#W3C-RDF11">W3C RDF 1.1</a></td></tr>
            <tr><td><code>|html</code></td><td>HyperText Markup Language, the standard markup language for documents designed to be displayed in a web browser.</td><td><a href="#WHATWG-HTML">WHATWG HTML</a></td></tr>
            <tr><td><code>|text</code></td><td>Plain text, as defined by MIME (Multipurpose Internet Mail Extensions).</td><td><a href="#RFC2046">RFC 2046</a></td></tr>
            <tr><td><code>|yaml</code></td><td>YAML Ain't Markup Language, a human-friendly data serialization standard.</td><td><a href="#YAML-SPEC">YAML 1.2.2</a></td></tr>
            <tr><td><code>|toml</code></td><td>Tom's Obvious, Minimal Language, a minimal configuration file format.</td><td><a href="#TOML-SPEC">TOML 1.0.0</a></td></tr>
        </tbody>
    </table>

    <h3>Decompression (<code>decomp:</code> prefix)</h3>
    <p>The <code>decomp:</code> prefix indicates a read-only decompression operation to access the contents of an archive or a compressed file. The language is extensible to any future compression technology using this prefix.</p>
    <table>
        <thead>
            <tr><th>Format</th><th>Description</th><th>Reference</th></tr>
        </thead>
        <tbody>
            <tr><td><code>|decomp:zip</code></td><td>ZIP file format, a widely used archive format that supports lossless data compression.</td><td><a href="#PKWARE-ZIP">PKWARE ZIP</a></td></tr>
            <tr><td><code>|decomp:tar</code></td><td>Tape Archive, a file format for collecting multiple files into one archive file for distribution or backup.</td><td><a href="#POSIX-TAR">POSIX.1-2017</a></td></tr>
            <tr><td><code>|decomp:gz</code></td><td>Gzip, a file format and a software application used for file compression and decompression.</td><td><a href="#RFC1952">RFC 1952</a></td></tr>
            <tr><td><code>|decomp:gzip</code></td><td>Alias for gz, referring to the Gzip stream format.</td><td><a href="#RFC1952">RFC 1952</a></td></tr>
            <tr><td><code>|decomp:7z</code></td><td>7z, an archive format that provides a high compression ratio.</td><td><a href="#7Z-FORMAT">7-Zip Format</a></td></tr>
        </tbody>
    </table>

    <h3>Decoding (<code>decode:</code> prefix)</h3>
    <p>The <code>decode:</code> prefix is used for various binary and text decoding techniques.</p>
    <table>
        <thead>
            <tr><th>Format</th><th>Description</th><th>Reference</th></tr>
        </thead>
        <tbody>
            <tr><td><code>|decode:base64</code></td><td>Base64 encoding scheme, used to represent binary data in an ASCII string format.</td><td><a href="#RFC4648">RFC 4648</a></td></tr>
            <tr><td><code>|decode:hex</code></td><td>Hexadecimal (Base16) encoding, used to represent binary data.</td><td><a href="#RFC4648">RFC 4648</a></td></tr>
            <tr><td><code>|decode:url</code></td><td>Percent-Encoding, used to encode information in a Uniform Resource Identifier (URI).</td><td><a href="#RFC3986">RFC 3986</a></td></tr>
        </tbody>
    </table>
  </section>
  
  <section id="uris-namespaces">
    <h2>URIs and Namespaces</h2>
    <p>UNL natively supports XML and RDF namespaces.</p>
    <pre class="example">
// Full URI
&lt;http://example.org/resource&gt;

// Prefixed namespace
prefix:name

// Default prefix
:name
    </pre>
  </section>

  <section id="predicates">
    <h2>Predicates (Filters)</h2>
    <p>
      Predicates, placed between square brackets <code>[...]</code>, are used to filter sets of nodes.
    </p>
    <pre class="example">
// Equality test
[@attr = "value"]

// Inequality test
[@attr != "value"]

// Numeric or alphabetical comparisons
[@attr &gt; 100]

// Regular expression matching
[@attr ~ "^pattern.*$"]

// Negation and logical operators
[!expr]
[expr1 & expr2]  // AND
[expr1 | expr2]  // OR
    </pre>
    
    <section id="positional-predicates">
      <h3>Positional Predicates</h3>
      <table>
        <thead>
          <tr><th>Predicate</th><th>Description</th></tr>
        </thead>
        <tbody>
          <tr><td><code>[n]</code></td><td>Selects the nth element in a list (1-based indexing).</td></tr>
          <tr><td><code>[position() = n]</code></td><td>Explicit alternative for the nth element.</td></tr>
          <tr><td><code>[last()]</code></td><td>Selects the last element in a list.</td></tr>
        </tbody>
      </table>
    </section>
  </section>
  
  <section id="functions">
    <h2>Built-in Functions</h2>
    
    <section id="structural-functions">
      <h3>Structural Navigation</h3>
      <dl>
        <dt><code>outer(selector, n)</code></dt>
        <dd>Navigates upwards <code>n</code> levels, jumping only over nodes that match the selector (e.g., <code>div|p</code>).</dd>
        <dt><code>inner(selector)</code></dt>
        <dd>Navigates to the terminal elements matching the selector within the current context.</dd>
      </dl>
    </section>
    
    <section id="filtering-functions">
      <h3>Hierarchical Filtering</h3>
      <dl>
        <dt><code>outermost(nodes)</code></dt>
        <dd>From a set of nodes, keeps only those that are not contained within other nodes in the set.</dd>
        <dt><code>innermost(nodes)</code></dt>
        <dd>From a set of nodes, keeps only those that do not contain any other nodes from the set.</dd>
      </dl>
    </section>
    
    <section id="utility-functions">
      <h3>Utility Functions</h3>
      <dl>
        <dt><code>only(elements)</code></dt><dd>Tests if the context contains only the specified elements.</dd>
        <dt><code>text()</code></dt><dd>Returns the text content of a node.</dd>
        <dt><code>count()</code></dt><dd>Returns the number of elements in a selection.</dd>
        <dt><code>type()</code></dt><dd>Returns the node's type (e.g., "element", "object", "string").</dd>
        <dt><code>not(expr)</code></dt><dd>Negation of a predicate expression.</dd>
      </dl>
    </section>
  </section>
  
  <section id="examples">
    <h2>Usage Examples by Format</h2>
    
    <section id="ex-xml">
      <h3>XML</h3>
      <pre class="example">
// Selects the 'isbn' attribute from the 'book' element
doc/book/@isbn

// Selects the 3rd paragraph of the 3rd chapter
doc/chapter[3]/para

// Selects an element with a namespace
doc/ns:element
      </pre>
    </section>

    <section id="ex-json">
      <h3>JSON</h3>
      <pre class="example">
// Accesses the 'city' property in an 'address' object
user/address/@city

// Accesses the 'name' property of the first user in an array
users[0]/@name

// Accesses an optional property
config?debug/@enabled
      </pre>
    </section>
    
    <section id="ex-csv">
      <h3>CSV</h3>
      <pre class="example">
// Content of the 'price' column from the 2nd row (index 1)
data|csv/row[1]/@price

// Row where the 'id' column has the value "ABC"
data|csv/row[@id="ABC"]
      </pre>
    </section>
    
    <section id="ex-rdf">
      <h3>RDF</h3>
      <pre class="example">
// Navigating through relationships
:person/foaf:knows/:name

// Selection by type
*[rdf:type = :Book]

// Navigating via a blank node to find a label
graph/?/rdfs:label
      </pre>
    </section>
  </section>
  
  <section id="advanced-examples">
    <h2>Advanced Examples</h2>

    <section id="ex-nested-multiformat">
      <h3>Nested Multi-Format Navigation</h3>
      <pre class="example">
// Chain: CSV → JSON → XML → RDF
data.csv|csv/
  row[@type="record"]/
    @metadata|json/
      content|xml/
        doc/@graph|rdf/
          :resource/rdfs:label
      </pre>
    </section>

    <section id="ex-archives">
      <h3>Navigating Archives</h3>
      <pre class="example">
// Chain: ZIP decompression → folder → file → XML content
package.zip|decomp:zip/
  data/
    2024/
      report.xml|xml/
        //section[@lang="fr"]/title
      </pre>
    </section>
    
    <section id="ex-complex-queries">
      <h3>Complex Queries</h3>
      <pre class="example">
// outer with mixed node types
article/outer(div|section|article, 3)/inner(p|span)

// Combining ancestors and siblings
//table[caption="Sales"]/../preceding-sibling::h2[1]

// Chaining optional navigations
user?profile?settings?theme/@value
      </pre>
    </section>
    
    <section id="ex-chained-transforms">
      <h3>Chained Transformations</h3>
      <pre class="example">
// Multiple decoding and decompression
@payload|decode:base64|decomp:gzip|json/data/items[*]/@id

// Mixed formats with predicates
archive|decomp:zip/*[@size > 1000]|xml//important
      </pre>
    </section>
  </section>
  
  <section id="references" class="appendix">
    <h2>References</h2>
    <dl>
        <dt id="W3C-XML">W3C XML 1.0</dt>
        <dd><a href="https://www.w3.org/TR/xml/">Extensible Markup Language (XML) 1.0 (Fifth Edition)</a>, T. Bray, et al., W3C Recommendation, 26 November 2008.</dd>
        <dt id="W3C-EXI">W3C EXI 1.0</dt>
        <dd><a href="https://www.w3.org/TR/exi/">Efficient XML Interchange (EXI) Format 1.0 (Second Edition)</a>, J. Schneider, et al., W3C Recommendation, 15 February 2011.</dd>
        <dt id="RFC8259">RFC 8259</dt>
        <dd><a href="https://www.rfc-editor.org/info/rfc8259">The JavaScript Object Notation (JSON) Data Interchange Format</a>, T. Bray, Ed., IETF, December 2017.</dd>
        <dt id="RFC4180">RFC 4180</dt>
        <dd><a href="https://www.rfc-editor.org/info/rfc4180">Common Format and MIME Type for Comma-Separated Values (CSV) Files</a>, Y. Shafranovich, IETF, October 2005.</dd>
        <dt id="W3C-RDF11">W3C RDF 1.1</dt>
        <dd><a href="https://www.w3.org/TR/rdf11-concepts/">RDF 1.1 Concepts and Abstract Syntax</a>, R. Cyganiak, et al., W3C Recommendation, 25 February 2014.</dd>
        <dt id="WHATWG-HTML">WHATWG HTML</dt>
        <dd><a href="https://html.spec.whatwg.org/multipage/">HTML Living Standard</a>, WHATWG.</dd>
        <dt id="RFC2046">RFC 2046</dt>
        <dd><a href="https://www.rfc-editor.org/info/rfc2046">Multipurpose Internet Mail Extensions (MIME) Part Two: Media Types</a>, N. Freed, et al., IETF, November 1996.</dd>
        <dt id="YAML-SPEC">YAML 1.2.2</dt>
        <dd><a href="https://yaml.org/spec/1.2.2/">YAML Ain’t Markup Language (YAML™) Version 1.2.2</a>, O. Ben-Kiki, et al., 1 October 2021.</dd>
        <dt id="TOML-SPEC">TOML 1.0.0</dt>
        <dd><a href="https://toml.io/v1.0.0/">Tom's Obvious, Minimal Language (TOML) v1.0.0</a>.</dd>
        <dt id="PKWARE-ZIP">PKWARE ZIP</dt>
        <dd><a href="https://pkware.cachefly.net/webdocs/casestudies/APPNOTE.TXT">.ZIP File Format Specification</a>, PKWARE Inc.</dd>
        <dt id="POSIX-TAR">POSIX.1-2017</dt>
        <dd><a href="https://pubs.opengroup.org/onlinepubs/9699919799/utilities/pax.html#tag_20_92_13_06">tar - tape archive utility</a>, IEEE Std 1003.1-2017.</dd>
        <dt id="RFC1952">RFC 1952</dt>
        <dd><a href="https://www.rfc-editor.org/info/rfc1952">GZIP file format specification version 4.3</a>, P. Deutsch, IETF, May 1996.</dd>
        <dt id="7Z-FORMAT">7-Zip Format</dt>
        <dd><a href="https://www.7-zip.org/7z.html">7z format</a>, Igor Pavlov.</dd>
        <dt id="RFC4648">RFC 4648</dt>
        <dd><a href="https://www.rfc-editor.org/info/rfc4648">The Base16, Base32, and Base64 Data Encodings</a>, S. Josefsson, IETF, October 2006.</dd>
        <dt id="RFC3986">RFC 3986</dt>
        <dd><a href="https://www.rfc-editor.org/info/rfc3986">Uniform Resource Identifier (URI): Generic Syntax</a>, T. Berners-Lee, et al., IETF, January 2005.</dd>
    </dl>
  </section>

</body>
</html>
