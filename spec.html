<!DOCTYPE html>
<html lang="en">
<head>
  <title>UNL - Unified Navigation Language - Final Specification v1.0</title>
  <meta charset="UTF-8">
  <script src="https://www.w3.org/Tools/respec/respec-w3c" class="remove"></script>
  
  <script class="remove">
    var respecConfig = {
      specStatus: "unofficial",
      shortName: "unl-spec-en",
      subtitle: "Final Specification v1.0",
      editors: [
        { name: "Specification Provided by User" }
      ],
      github: "https://github.com/mozasaur/unl",
      issueBase: "https://github.com/mozasaur/unl/issues/",
    };
  </script>
</head>
<body>

  <section id="abstract">
    <h2>Abstract</h2>
    <p>
      The Unified Navigation Language (UNL) provides a single, coherent syntax to query, navigate, and transform data across multiple structured formats such as XML, JSON, CSV, and RDF. It draws inspiration from proven concepts like XPath and CSS selectors while introducing innovative features like optional navigation, built-in format transformation, advanced structural navigation functions, and a powerful sequence processing pipeline. The goal is to offer a single, intuitive language for all data formats.
    </p>
  </section>

  <section id="sotd">
    </section>
  
  <section id="intro">
    <h2>Introduction</h2>
    <p>
      In an increasingly heterogeneous data ecosystem, developers must master multiple query languages (XPath for XML, JSONPath for JSON, SPARQL for RDF, etc.). UNL was designed to eliminate this complexity by offering a unified abstraction layer.
    </p>
    <p>
      UNL's key innovations are:
    </p>
    <ul>
      <li><strong>Optional Navigation <code>?</code>:</strong> A unique syntax to elegantly handle variable or incomplete data structures.</li>
      <li><strong>Node/Leaf Distinction (<code>@</code>):</strong> Provides fundamental semantic clarity by distinguishing between navigable containers and final values.</li>
      <li><strong>Advanced Structural Navigation (<code>outer()</code>):</strong> Enables complex, type-based navigation jumps that are difficult to achieve with other languages.</li>
      <li><strong>Fluid Transformations (<code>|format</code>):</strong> The pipe operator allows for on-the-fly data conversion within a single navigation expression.</li>
      <li><strong>Native URI and Namespace Support:</strong> Full integration with semantic web standards (RDF, XML) via EQName syntax.</li>
      <li><strong>Unified Syntax:</strong> One language to rule all your formats.</li>
    </ul>
    <h3>Design Principles</h3>
    <ul>
      <li><strong>LALR(1) Parsable:</strong> The grammar is designed to be unambiguous and easily parsable.</li>
      <li><strong>Extensible:</strong> The system can incorporate new formats without changing the core parser.</li>
      <li><strong>Compatible:</strong> It is inspired by the best ideas from XPath and CSS without creating conflicts.</li>
      <li><strong>Intuitive:</strong> The syntax is designed to be read naturally.</li>
    </ul>
  </section>

  <section id="conformance">
      </section>
  
  <section id="execution-models">
      <h2>Operating Models</h2>
      <p>A UNL query is always evaluated against an initial context. The initial context can be a single document or a sequence of documents.</p>
      
      <section id="in-memory-nav">
          <h3>In-Memory Navigation</h3>
          <p>
              In this model, the UNL engine operates on a data structure that is already parsed and held in memory. The context can be a single root <a>Node</a> or a sequence of <a>Nodes</a>. The UNL query is an expression that navigates this existing structure directly. This corresponds to the <code>InMemoryQuery</code> production in the EBNF grammar.
          </p>
          <pre class="example">
// Pseudo-code for a UNL library
let myJson = { "user": { "name": "John" } };
let inMemoryQuery = "user/@name";

// The engine executes the path against the in-memory object.
let result = unl.run(myJson, inMemoryQuery); // result: "John"
          </pre>
      </section>
      
      <section id="resource-loading-nav">
          <h3>Resource Loading and Navigation</h3>
          <p>
              In this model, the UNL query begins with a <strong>Resource Locator</strong> (e.g., a file path or a full URI). This locator can be a single resource identifier or a pattern (e.g., a glob) that resolves to a sequence of resources. This locator is immediately followed by a mandatory transformation pipe (<code>|</code>) that instructs the engine how to fetch and parse the resource(s). This corresponds to the <code>ResourceQuery</code> production in the EBNF grammar.
          </p>
          <div class="note">
            <h4>Important Note on Resource Locators</h4>
            <p>
                The <code>ResourceLocator</code> part of a query is treated as a literal string path or URI. It only supports the standard <code>/</code> as a path separator. The special UNL navigation operators such as <code>?</code> (optional navigation), <code>@</code> (leaf access), or wildcards are not valid within the locator itself. UNL's navigation logic is only applied to the path expression that follows the first transformation pipe.
            </p>
          </div>
          <pre class="example nohighlight">
// The UNL query itself contains the resource locator.
let resourceQuery = "data.csv|csv/*[1]/@price";
let anotherQuery = "http://example.com/data.zip|decomp:zip/docs/report.xml|xml//title";

// The engine identifies the resource locator, fetches and parses it,
// then navigates the resulting structure.
let result1 = unl.run(resourceQuery);
let result2 = unl.run(anotherQuery);
          </pre>
      </section>
  </section>
  
  <section id="sequence-handling">
    <h2>Sequence Transformations</h2>
    <p>
        UNL includes a powerful two-stage pipeline model to process sequences of results. This allows for both efficient, low-memory streaming and complex, full-sequence aggregations.
    </p>
    
    <section>
        <h3>The Streaming Pipeline (<code>|</code>)</h3>
        <p>
            The default pipeline, using the single pipe <code>|</code>, operates in a streaming fashion. Each operator processes items one by one as they arrive, typically with minimal memory overhead (<code>O(1)</code> or `O(k)`). This model is highly efficient for large datasets. It includes format parsing, decoding, and a class of "streamable aggregates".
        </p>
        <h4>Streamable Aggregate Operators</h4>
        <p>These operators can produce their result without needing to store the entire sequence in memory. They operate in the standard streaming pipeline.</p>
        <table>
            <thead>
                <tr><th>Operator</th><th>Description</th></tr>
            </thead>
            <tbody>
                <tr><td><code>| head(n)</code></td><td>Takes the first <code>n</code> items from the stream and terminates the pipeline.</td></tr>
                <tr><td><code>| tail(n)</code></td><td>Maintains a fixed-size buffer to output the last <code>n</code> items once the stream ends.</td></tr>
                <tr><td><code>| count</code></td><td>Counts all items in the stream, using constant memory, and outputs a single leaf with the total at the end.</td></tr>
                <tr><td><code>| sum</code></td><td>Calculates the sum of all items in a numeric stream.</td></tr>
                <tr><td><code>| avg</code></td><td>Calculates the average of all items in a numeric stream.</td></tr>
                <tr><td><code>| min</code></td><td>Finds the minimum value in a stream.</td></tr>
                <tr><td><code>| max</code></td><td>Finds the maximum value in a stream.</td></tr>
            </tbody>
        </table>
    </section>
    
    <section>
        <h3>The Aggregation Pipeline (<code>||</code>)</h3>
        <p>
            The double pipe <code>||</code> acts as a <strong>blocking barrier</strong>. It instructs the engine to stop streaming, collect all results from the preceding pipeline into a full sequence in memory (<code>O(n)</code>), and then pass that complete sequence to the aggregation operators that follow. This is a conscious trade-off made by the user to enable powerful, whole-sequence operations.
        </p>
        <h4>Blocking Aggregate Operators</h4>
        <p>These operators <em class="rfc2119">MUST</em> be preceded by the <code>||</code> barrier, as they require the entire sequence to be available to perform their work.</p>
        <table>
            <thead>
                <tr><th>Operator</th><th>Description</th></tr>
            </thead>
            <tbody>
                <tr><td><code>| order-by(key)</code></td><td>Sorts the entire sequence based on a key expression. Direction (asc/desc) and type (numeric/text) can be specified.</td></tr>
                <tr><td><code>| group-by(key)</code></td><td>Groups items in the sequence based on a key expression. Produces a sequence of group nodes.</td></tr>
                <tr><td><code>| distinct</code></td><td>Removes duplicate items from the sequence.</td></tr>
            </tbody>
        </table>
        <div class="note">
            <h4>Final Query Results</h4>
            <p>The result of a UNL query is the data produced by the final operator in the pipeline. If the pipeline ends with an aggregation operator like <code>order-by</code> or `distinct`, the result is a sequence (an array of nodes or leaves). The task of serializing this final sequence into a specific document format (e.g., by wrapping it in a root element) is left to the calling application or environment.</p>
        </div>
    </section>
  </section>

  <section id="core-concepts">
    <h2>Fundamental Principles</h2>
    <p>
      UNL's data model is based on three core principles.
    </p>
    <dl>
      <dt><dfn>Node</dfn> (No Prefix)</dt>
      <dd>Represents a navigable structure that contains other <a>nodes</a> or leaves. Examples: an XML element, a JSON object, a CSV row represented as a node.</dd>
      
      <dt><dfn>Leaf</dfn> (<code>@</code> Prefix)</dt>
      <dd>Represents a final, non-navigable atomic value. It is the endpoint of a navigation path. Examples: a string, a number, a boolean value, or a node's metadata attribute.</dd>
      
      <dt>The Pipe Transformation Principle (<code>|</code> Operator)</dt>
      <dd>
        A <a>Leaf</a> is normally a terminal point of navigation. However, the pipe operator <code>|</code> allows the value of a Leaf to be re-interpreted as a new data source. This operation performs a <strong>type-casting</strong> of the leaf's value, creating a new, navigable <a>Node</a> structure. This mechanism is the key to nested parsing and is fundamental to UNL's power.
        <br/>
        Symbolically: <code>.../<a>Leaf</a>(String) |json → New <a>Node</a>(JSON)</code>
      </dd>
    </dl>
  </section>
  
  <section id="syntax">
    <h2>Navigation Syntax</h2>
    
    <section id="nav-base">
      <h3>Base Navigation</h3>
      <table>
        <thead>
          <tr><th>Operator</th><th>Description</th></tr>
        </thead>
        <tbody>
          <tr><td><code>/</code></td><td>Mandatory navigation to a child. Must exist.</td></tr>
          <tr><td><code>?</code></td><td>Optional navigation between nodes. Allows chaining paths that may not exist (<code>a?b</code> is equivalent to <code>a</code> or <code>a/b</code>).</td></tr>
          <tr><td><code>?</code> (wildcard)</td><td>Single wildcard when used alone. Represents any single child (<code>a/?/c</code>).</td></tr>
          <tr><td><code>*</code></td><td>Multiple wildcard. Represents all child <a>nodes</a>.</td></tr>
          <tr><td><code>**</code></td><td>Descendant wildcard. Represents all descendant <a>nodes</a>.</td></tr>
          <tr><td><code>.</code></td><td>Represents the current <a>node</a>.</td></tr>
          <tr><td><code>@name</code></td><td>Accesses a named <a href="#dfn-leaf">leaf</a>.</td></tr>
          <tr><td><code>@*</code></td><td>Selects all <a href="#dfn-leaf">leaves</a> of the current <a>node</a> as an ordered collection.</td></tr>
          <tr><td><code>#id</code></td><td>Direct access to a <a>node</a> by its ID or URI.</td></tr>
        </tbody>
      </table>
    </section>
    
    <section id="nav-vertical">
      <h3>Vertical Navigation (Ancestors)</h3>
      <table>
        <thead>
          <tr><th>Operator</th><th>Description</th></tr>
        </thead>
        <tbody>
          <tr><td><code>..</code></td><td>Direct parent.</td></tr>
          <tr><td><code>..n</code></td><td>Nth ancestor (e.g., <code>..2</code> for the grandparent).</td></tr>
          <tr><td><code>...</code></td><td>All ancestors up to the root.</td></tr>
        </tbody>
      </table>
    </section>
    
    <section id="nav-lateral">
      <h3>Lateral Navigation (Siblings)</h3>
      <table>
        <thead>
          <tr><th>Operator</th><th>Description</th></tr>
        </thead>
        <tbody>
          <tr><td><code>+</code></td><td>The immediate following-sibling.</td></tr>
          <tr><td><code>-</code></td><td>The immediate preceding-sibling.</td></tr>
          <tr><td><code>~</code></td><td>All following-siblings.</td></tr>
          <tr><td><code>~~</code></td><td>All preceding-siblings.</td></tr>
        </tbody>
      </table>
    </section>
  </section>

  <section id="special-chars">
    <h2>Handling Special Characters and Quoting</h2>
    <p>
        Many characters have a special syntactic meaning in UNL (e.g., <code>/ ? @ * [ ] ( ) | . :</code>). If a node or leaf name in the source data contains one of these characters, it must be enclosed in single (<code>'</code>) or double (<code>"</code>) quotes to be treated as a literal name.
    </p>
    <p>
        This quoting mechanism applies to any path segment that is a name test.
    </p>
    
    <h3>Rules for Quoting</h3>
    <dl>
        <dt>When to Quote</dt>
        <dd>A name segment <em class="rfc2119">MUST</em> be quoted if it contains any special UNL characters or if it is ambiguous with a numeric literal (e.g., a key named "3").</dd>
        
        <dt>Escaping within Quotes</dt>
        <dd>To include a quote character within a quoted name, it <em class="rfc2119">MUST</em> be escaped with a backslash (<code>\</code>). A literal backslash <em class="rfc2119">MUST</em> also be escaped (<code>\\</code>).</dd>
    </dl>
    
    <h3>Examples</h3>
    <pre class="example">
// Example 1: JSON key with a forward slash
// Data: { "a/b": { "c": 1 } }
// Query: "a/b"/c/@value

// Example 2: Filename with special characters
// Resource Locator: my-archive.zip
// Path in zip: reports/report-[v1].xml
my-archive.zip|decomp:zip/reports/"report-[v1].xml"|xml//...

// Example 3: XML element name with dots
// Data: &lt;com.example.Node&gt;Value&lt;/com.example.Node&gt;
// Query: "com.example.Node"/text()

// Example 4: Quoting a name containing quotes
// Data: { "node with \"quotes\"": 42 }
// Query: "node with \\\"quotes\\\""/@value
    </pre>
  </section>

  <section id="uris-namespaces">
    <h2>URIs and Namespaces</h2>
    <p>
        UNL provides robust support for namespaced data formats like XML and RDF. To ensure unambiguous queries, UNL adopts the <strong>EQName</strong> (Extended QName) notation from [[XPATH-31]].
    </p>
    <dl>
        <dt>Prefixed QName (e.g., <code>atom:title</code>)</dt>
        <dd>The classic <code>prefix:local-name</code> syntax. Its use is supported but discouraged in favor of EQNames, as it relies on an external context to map the prefix to a namespace URI.</dd>
        
        <dt>EQName / URI-Qualified Name (e.g., <code>Q{http://www.w3.org/2005/Atom}title</code>)</dt>
        <dd>The <code>Q{namespace-uri}local-name</code> syntax. This is the <strong>recommended approach</strong> as it includes the full namespace URI directly within the expression, making queries self-contained and unambiguous.</dd>
    </dl>
    <p>
        Because RDF predicates are full URIs, using the EQName syntax is the most precise method for navigating RDF graphs.
    </p>
    <pre class="example">
// EQName syntax is unambiguous and recommended
Q{http://www.w3.org/2005/Atom}feed/Q{http://www.w3.org/2005/Atom}entry/title

// EQName used to query an RDF property
Q{http://xmlns.com/foaf/0.1/}Person/Q{http://xmlns.com/foaf/0.1/}knows

// Full URI used in a predicate value
*[rdf:type = &lt;http://xmlns.com/foaf/0.1/Person&gt;]
    </pre>
  </section>

  <section id="transforms">
    <h2>Format Transformations</h2>
    <p>
      The pipe operator (<code>|</code>) is used for transformations. As described in the <a href="#execution-models">Operating Models</a>, the first pipe in a <code>ResourceQuery</code> serves to load and parse a resource. Subsequent pipes transform the current selection, often by type-casting a <a>Leaf</a>'s value into a new <a>Node</a> structure, as defined in the <a href="#core-concepts">Core Principles</a>.
    </p>
    <div class="note">
      <h4>Note on Sequences</h4>
      <p>All transformations described below adhere to the Implicit Iteration principle. When the input is a <code>Sequence(T)</code>, the output will be a <code>Sequence(U)</code>, where the transformation <code>T → U</code> has been applied to each item.</p>
    </div>
    
    <h3>Data Serialization Formats</h3>
    <p>These transformations parse a string-based <a href="#dfn-leaf">Leaf</a> or resource into a navigable <a>Node</a> structure.</p>
    <table>
        <thead>
            <tr><th>Format</th><th>Description</th><th>Type Signature</th><th>Reference</th></tr>
        </thead>
        <tbody>
            <tr><td><code>|xml</code></td><td>Extensible Markup Language.</td><td><code>Leaf(String) → Node(XML)</code></td><td><a href="#W3C-XML">W3C XML 1.0</a></td></tr>
            <tr><td><code>|exi</code></td><td>Efficient XML Interchange (binary XML).</td><td><code>Leaf(Binary) → Node(XML)</code></td><td><a href="#W3C-EXI">W3C EXI 1.0</a></td></tr>
            <tr><td><code>|json</code></td><td>JavaScript Object Notation.</td><td><code>Leaf(String) → Node(Object | Array)</code></td><td><a href="#RFC8259">RFC 8259</a></td></tr>
            <tr><td><code>|csv</code></td><td>Comma-Separated Values.</td><td><code>Leaf(String) → Node(Array)</code></td><td><a href="#RFC4180">RFC 4180</a></td></tr>
            <tr><td><code>|rdf</code></td><td>Resource Description Framework.</td><td><code>Leaf(String) → Node(Graph)</code></td><td><a href="#W3C-RDF11">W3C RDF 1.1</a></td></tr>
            <tr><td><code>|html</code></td><td>HyperText Markup Language.</td><td><code>Leaf(String) → Node(HTML)</code></td><td><a href="#WHATWG-HTML">WHATWG HTML</a></td></tr>
            <tr><td><code>|text</code></td><td>Plain text. Useful for converting binary leaves to strings.</td><td><code>Leaf(Binary) → Leaf(String)</code></td><td><a href="#RFC2046">RFC 2046</a></td></tr>
            <tr><td><code>|yaml</code></td><td>YAML Ain't Markup Language.</td><td><code>Leaf(String) → Node(Object | Array)</code></td><td><a href="#YAML-SPEC">YAML 1.2.2</a></td></tr>
            <tr><td><code>|toml</code></td><td>Tom's Obvious, Minimal Language.</td><td><code>Leaf(String) → Node(Object)</code></td><td><a href="#TOML-SPEC">TOML 1.0.0</a></td></tr>
        </tbody>
    </table>

    <h3>Decompression (<code>decomp:</code> prefix)</h3>
    <p>These transformations operate on a resource or a binary <a href="#dfn-leaf">Leaf</a>, decompressing it to expose a virtual filesystem of <a>Nodes</a>.</p>
    <table>
        <thead>
            <tr><th>Format</th><th>Description</th><th>Type Signature</th><th>Reference</th></tr>
        </thead>
        <tbody>
            <tr><td><code>|decomp:zip</code></td><td>ZIP file format.</td><td><code>(ResourceLocator | Leaf(Binary)) → Node(Archive)</code></td><td><a href="#PKWARE-ZIP">PKWARE ZIP</a></td></tr>
            <tr><td><code>|decomp:tar</code></td><td>Tape Archive.</td><td><code>(ResourceLocator | Leaf(Binary)) → Node(Archive)</code></td><td><a href="#POSIX-TAR">POSIX.1-2017</a></td></tr>
            <tr><td><code>|decomp:gz</code></td><td>Gzip compression.</td><td><code>Leaf(Binary) → Leaf(Binary)</code></td><td><a href="#RFC1952">RFC 1952</a></td></tr>
            <tr><td><code>|decomp:7z</code></td><td>7z archive format.</td><td><code>(ResourceLocator | Leaf(Binary)) → Node(Archive)</code></td><td><a href="#7Z-FORMAT">7-Zip Format</a></td></tr>
            <tr><td><code>|decomp:rar</code></td><td>Roshal Archive.</td><td><code>(ResourceLocator | Leaf(Binary)) → Node(Archive)</code></td><td>N/A</td></tr>
            <tr><td><code>|decomp:xz</code></td><td>XZ compression.</td><td><code>Leaf(Binary) → Leaf(Binary)</code></td><td><a href="#XZ-SPEC">XZ Format</a></td></tr>
            <tr><td><code>|decomp:bz2</code></td><td>Bzip2 compression.</td><td><code>Leaf(Binary) → Leaf(Binary)</code></td><td><a href="#BZIP2-SPEC">Bzip2 Format</a></td></tr>
            <tr><td><code>|decomp:zstd</code></td><td>Zstandard compression.</td><td><code>Leaf(Binary) → Leaf(Binary)</code></td><td><a href="#RFC8878">RFC 8878</a></td></tr>
            <tr><td><code>|decomp:brotli</code></td><td>Brotli compression.</td><td><code>Leaf(Binary) → Leaf(Binary)</code></td><td><a href="#RFC7932">RFC 7932</a></td></tr>
        </tbody>
    </table>

    <h3>Decoding (<code>decode:</code> prefix)</h3>
    <p>These are intermediate transformations that type-cast a <a href="#dfn-leaf">Leaf</a>'s value.</p>
    <table>
        <thead>
            <tr><th>Format</th><th>Description</th><th>Type Signature</th><th>Reference</th></tr>
        </thead>
        <tbody>
            <tr><td><code>|decode:base64</code></td><td>Base64 decoding.</td><td><code>Leaf(String) → Leaf(Binary)</code></td><td><a href="#RFC4648">RFC 4648</a></td></tr>
            <tr><td><code>|decode:hex</code></td><td>Hexadecimal decoding.</td><td><code>Leaf(String) → Leaf(Binary)</code></td><td><a href="#RFC4648">RFC 4648</a></td></tr>
            <tr><td><code>|decode:url</code></td><td>Percent-decoding.</td><td><code>Leaf(String) → Leaf(String)</code></td><td><a href="#RFC3986">RFC 3986</a></td></tr>
            <tr><td><code>|decode:html-entities</code></td><td>Decodes HTML/XML character entities.</td><td><code>Leaf(String) → Leaf(String)</code></td><td><a href="#WHATWG-HTML">WHATWG HTML</a></td></tr>
            <tr><td><code>|decode:json-string</code></td><td>Un-escapes a string that was itself encoded as a JSON string literal.</td><td><code>Leaf(String) → Leaf(String)</code></td><td><a href="#RFC8259">RFC 8259</a></td></tr>
            <tr><td><code>|decode:punycode</code></td><td>Decodes Punycode strings (IDN).</td><td><code>Leaf(String) → Leaf(String)</code></td><td><a href="#RFC3492">RFC 3492</a></td></tr>
            <tr><td><code>|decode:quoted-printable</code></td><td>Decodes Quoted-Printable (MIME) content.</td><td><code>Leaf(String) → Leaf(String)</code></td><td><a href="#RFC2045">RFC 2045</a></td></tr>
        </tbody>
    </table>
  </section>
  
  <section id="predicates">
    <h2>Predicates (Filters)</h2>
    <p>
      Predicates, placed between square brackets <code>[...]</code>, are used to filter sets of <a>nodes</a>.
    </p>
    <pre class="example">
// Equality test
[@attr = "value"]

// Inequality test
[@attr != "value"]

// Numeric or alphabetical comparisons
[@attr > 100]

// Regular expression matching
[@attr ~ "^pattern.*$"]

// Negation and logical operators
[!expr]
[expr1 & expr2]  // AND
[expr1 | expr2]  // OR
    </pre>
    
    <section id="positional-predicates">
      <h3>Positional Predicates</h3>
      <table>
        <thead>
          <tr><th>Predicate</th><th>Description</th></tr>
        </thead>
        <tbody>
          <tr><td><code>[n]</code></td><td>Selects the nth element in a list (1-based indexing).</td></tr>
          <tr><td><code>[position() = n]</code></td><td>Explicit alternative for the nth element.</td></tr>
          <tr><td><code>[last()]</code></td><td>Selects the last element in a list.</td></tr>
        </tbody>
      </table>
    </section>
  </section>
  
  <section id="functions">
    <h2>Built-in Functions</h2>
    
    <section id="structural-functions">
      <h3>Structural Navigation</h3>
      <dl>
        <dt><code>outer(selector, n)</code></dt>
        <dd>Navigates upwards <code>n</code> levels, jumping only over <a>nodes</a> that match the selector (e.g., <code>div|p</code>).</dd>
        <dt><code>inner(selector)</code></dt>
        <dd>Navigates to the terminal elements matching the selector within the current context.</dd>
      </dl>
    </section>
    
    <section id="filtering-functions">
      <h3>Hierarchical Filtering</h3>
      <dl>
        <dt><code>outermost(nodes)</code></dt>
        <dd>From a set of <a>nodes</a>, keeps only those that are not contained within other <a>nodes</a> in the set.</dd>
        <dt><code>innermost(nodes)</code></dt>
        <dd>From a set of <a>nodes</a>, keeps only those that do not contain any other <a>nodes</a> from the set.</dd>
      </dl>
    </section>
    
    <section id="utility-functions">
      <h3>Utility Functions</h3>
      <dl>
        <dt><code>only(elements)</code></dt><dd>Tests if the context contains only the specified elements.</dd>
        <dt><code>text()</code></dt><dd>Returns the text content of a <a>node</a>.</dd>
        <dt><code>count()</code></dt><dd>Returns the number of elements in a selection.</dd>
        <dt><code>type()</code></dt><dd>Returns the <a data-lt="Node">node's</a> type (e.g., "element", "object", "string").</dd>
        <dt><code>not(expr)</code></dt><dd>Negation of a predicate expression.</dd>
      </dl>
    </section>
  </section>
  
  <section id="examples">
    <h2>Examples</h2>
    <p>The following examples illustrate the two operating models.</p>
    
    <section id="ex-in-memory">
        <h3>In-Memory Mode Examples</h3>
        <pre class="example">
// Assumes 'doc' is a pre-parsed XML document object.
doc/book/@isbn

// Assumes 'users' is a pre-parsed JSON array.
users[1]/@name

// Assumes a pre-parsed RDF graph. Uses EQName for clarity.
Q{http://example.org/ontology#}Person[1]/Q{http://xmlns.com/foaf/0.1/}name
        </pre>
    </section>
    
    <section id="ex-resource-loading">
        <h3>Resource Loading Mode Examples</h3>
        <pre class="example nohighlight">
// Query starts with a file path, followed by |csv to parse it into an array.
data.csv|csv/*[@id="ABC"]/@name

// Query starts with a full URI. Navigation to a file is by name.
http://example.com/data.zip|decomp:zip/docs/report.xml|xml//title

// The wildcard selects file and directory nodes, which are then filtered by size.
./archive.zip|decomp:zip/*[@size > 1000]|xml//important
        </pre>
    </section>
  </section>
  
  <section id="references" class="appendix">
    <h2>References</h2>
    <dl>
        <dt id="RFC2119">RFC 2119</dt>
        <dd><a href="https://www.rfc-editor.org/info/rfc2119">Key words for use in RFCs to Indicate Requirement Levels</a>, S. Bradner, IETF, March 1997.</dd>
        <dt id="RFC8174">RFC 8174</dt>
        <dd><a href="https://www.rfc-editor.org/info/rfc8174">Ambiguity of Uppercase vs Lowercase in RFC 2119 Key Words</a>, B. Leiba, IETF, May 2017.</dd>
        <dt id="ISO-IEC-14977">ISO/IEC 14977:1996</dt>
        <dd><a href="https://www.iso.org/standard/26153.html">Information technology — Syntactic metalanguage — Extended BNF</a>.</dd>
        <dt id="W3C-XML">W3C XML 1.0</dt>
        <dd><a href="https://www.w3.org/TR/xml/">Extensible Markup Language (XML) 1.0 (Fifth Edition)</a>, T. Bray, et al., W3C Recommendation, 26 November 2008.</dd>
        <dt id="XML-NAMES">XML-NAMES</dt>
        <dd><a href="https://www.w3.org/TR/xml-names/">Namespaces in XML 1.0 (Third Edition)</a>, T. Bray, et al., W3C Recommendation, 8 December 2009.</dd>
        <dt id="XPATH-31">XPATH 3.1</dt>
        <dd><a href="https://www.w3.org/TR/xpath-31/">XML Path Language (XPath) 3.1</a>, J. Robie, et al., W3C Recommendation, 21 March 2017.</dd>
        <dt id="W3C-EXI">W3C EXI 1.0</dt>
        <dd><a href="https://www.w3.org/TR/exi/">Efficient XML Interchange (EXI) Format 1.0 (Second Edition)</a>, J. Schneider, et al., W3C Recommendation, 15 February 2011.</dd>
        <dt id="RFC8259">RFC 8259</dt>
        <dd><a href="https://www.rfc-editor.org/info/rfc8259">The JavaScript Object Notation (JSON) Data Interchange Format</a>, T. Bray, Ed., IETF, December 2017.</dd>
        <dt id="RFC4180">RFC 4180</dt>
        <dd><a href="https://www.rfc-editor.org/info/rfc4180">Common Format and MIME Type for Comma-Separated Values (CSV) Files</a>, Y. Shafranovich, IETF, October 2005.</dd>
        <dt id="W3C-RDF11">W3C RDF 1.1</dt>
        <dd><a href="https://www.w3.org/TR/rdf11-concepts/">RDF 1.1 Concepts and Abstract Syntax</a>, R. Cyganiak, et al., W3C Recommendation, 25 February 2014.</dd>
        <dt id="WHATWG-HTML">WHATWG HTML</dt>
        <dd><a href="https://html.spec.whatwg.org/multipage/">HTML Living Standard</a>, WHATWG.</dd>
        <dt id="RFC2046">RFC 2046</dt>
        <dd><a href="https://www.rfc-editor.org/info/rfc2046">Multipurpose Internet Mail Extensions (MIME) Part Two: Media Types</a>, N. Freed, et al., IETF, November 1996.</dd>
        <dt id="YAML-SPEC">YAML 1.2.2</dt>
        <dd><a href="https://yaml.org/spec/1.2.2/">YAML Ain’t Markup Language (YAML™) Version 1.2.2</a>, O. Ben-Kiki, et al., 1 October 2021.</dd>
        <dt id="TOML-SPEC">TOML 1.0.0</dt>
        <dd><a href="https://toml.io/v1.0.0/">Tom's Obvious, Minimal Language (TOML) v1.0.0</a>.</dd>
        <dt id="PKWARE-ZIP">PKWARE ZIP</dt>
        <dd><a href="https://pkware.cachefly.net/webdocs/casestudies/APPNOTE.TXT">.ZIP File Format Specification</a>, PKWARE Inc.</dd>
        <dt id="POSIX-TAR">POSIX.1-2017</dt>
        <dd><a href="https://pubs.opengroup.org/onlinepubs/9699919799/utilities/pax.html#tag_20_92_13_06">tar - tape archive utility</a>, IEEE Std 1003.1-2017.</dd>
        <dt id="RFC1952">RFC 1952</dt>
        <dd><a href="https://www.rfc-editor.org/info/rfc1952">GZIP file format specification version 4.3</a>, P. Deutsch, IETF, May 1996.</dd>
        <dt id="7Z-FORMAT">7-Zip Format</dt>
        <dd><a href="https://www.7-zip.org/7z.html">7z format</a>, Igor Pavlov.</dd>
        <dt id="XZ-SPEC">XZ Format</dt>
        <dd><a href="https://tukaani.org/xz/xz-file-format.txt">The .xz File Format</a>, Tukaani.</dd>
        <dt id="BZIP2-SPEC">Bzip2 Format</dt>
        <dd><a href="https://github.com/dsnet/compress/blob/master/doc/bzip2-format.pdf">BZIP2 Format Specification</a>, J. Seward.</dd>
        <dt id="RFC8878">RFC 8878</dt>
        <dd><a href="https://www.rfc-editor.org/info/rfc8878">Zstandard Compression Algorithm</a>, Y. Collet & M. Kucherawy, Ed., IETF, February 2021.</dd>
        <dt id="RFC7932">RFC 7932</dt>
        <dd><a href="https://www.rfc-editor.org/info/rfc7932">Brotli Compressed Data Format</a>, J. Alakuijala & Z. Szabadka, IETF, July 2016.</dd>
        <dt id="RFC4648">RFC 4648</dt>
        <dd><a href="https://www.rfc-editor.org/info/rfc4648">The Base16, Base32, and Base64 Data Encodings</a>, S. Josefsson, IETF, October 2006.</dd>
        <dt id="RFC3986">RFC 3986</dt>
        <dd><a href="https://www.rfc-editor.org/info/rfc3986">Uniform Resource Identifier (URI): Generic Syntax</a>, T. Berners-Lee, et al., IETF, January 2005.</dd>
        <dt id="RFC3492">RFC 3492</dt>
        <dd><a href="https://www.rfc-editor.org/info/rfc3492">Punycode: A Bootstring encoding of Unicode for Internationalized Domain Names in Applications (IDNA)</a>, A. Costello, IETF, March 2003.</dd>
        <dt id="RFC2045">RFC 2045</dt>
        <dd><a href="https://www.rfc-editor.org/info/rfc2045">Multipurpose Internet Mail Extensions (MIME) Part One: Format of Internet Message Bodies</a>, N. Freed & N. Borenstein, IETF, November 1996.</dd>
    </dl>
  </section>
  
  <section id="ebnf-grammar" class="appendix">
    <h2>EBNF Grammar for UNL v1.0</h2>
    <p>This appendix provides a non-normative grammar for the Unified Navigation Language, with a syntax conforming to the EBNF standard [[ISO-IEC-14977]].</p>
    <pre class="grammar">
(* A full query can have an optional, final aggregation stage *)
UNLQuery           ::= ( ResourceQuery | InMemoryQuery ) ( '||' AggregationPath )?

(* Form 1: Starts with a resource, requires a parsing transformation *)
ResourceQuery      ::= ResourceLocator StreamingPipe ( StreamingPipe )*

(* Form 2: Starts with a path, operates on a pre-existing context *)
InMemoryQuery      ::= Path ( StreamingPipe )*

StreamingPipe      ::= '|' ( DataFormat | DecompTransform | DecodeTransform | StreamingAggregate )
AggregationPath    ::= BlockingAggregate ( '|' BlockingAggregate )*

Path               ::= Step ( ( '/' | '?' ) Step )*
Step               ::= ( PrimaryStep | Axis ) Predicate*

PrimaryStep        ::= NameTest | Wildcard | LeafAccess | IdAccess | '.' | '(' Path ')'

(* A NameTest can be a standard EQName or a quoted literal string *)
NameTest           ::= EQName | Literal
LeafAccess         ::= '@' ( EQName | '*' | Literal )

EQName             ::= QName | URIQualifiedName
QName              ::= ( NCName ':' )? NCName
URIQualifiedName   ::= 'Q{' URILiteral '}' NCName

Wildcard           ::= '*' | '**' | '?'
IdAccess           ::= '#' NCName
Axis               ::= '..' | '..' Integer | '...' | '+' | '-' | '~' | '~~'

Predicate          ::= '[' FilterExpression ']'

FilterExpression   ::= OrExpression
OrExpression       ::= AndExpression ( '|' AndExpression )*
AndExpression      ::= EqualityExpression ( '&amp;' EqualityExpression )*
EqualityExpression ::= RelationalExpression ( ( '=' | '!=' ) RelationalExpression )?
RelationalExpression ::= PrimaryFilterExpr ( ( '&lt;' | '&gt;' | '&lt;=' | '&gt;=' | '~' ) PrimaryFilterExpr )*

PrimaryFilterExpr  ::= Literal | FunctionCall | Path | LeafAccess | '!' FilterExpression | '(' FilterExpression ')' | Integer

FunctionCall       ::= NCName '(' ( FilterExpression ( ',' FilterExpression )* )? ')'

(* Operator Definitions *)
DataFormat         ::= 'xml' | 'exi' | 'json' | 'csv' | 'rdf' | 'html' | 'text' | 'yaml' | 'toml'
DecompTransform    ::= 'decomp:' ( 'zip' | 'tar' | 'gz' | '7z' | 'gzip' | 'rar' | 'xz' | 'bz2' | 'zstd' | 'brotli' )
DecodeTransform    ::= 'decode:' ( 'base64' | 'hex' | 'url' | 'html-entities' | 'json-string' | 'punycode' | 'quoted-printable' )
StreamingAggregate ::= 'count' | 'sum' | 'avg' | 'min' | 'max' | 'head' '(' Integer ')' | 'tail' '(' Integer ')'
BlockingAggregate  ::= 'distinct' | 'order-by' '(' Path ')' | 'group-by' '(' Path ')'

(* Lexical Definitions (Informal) *)
ResourceLocator    ::= (* A literal string representing a URI or file path. It uses standard '/' separators and does not support UNL operators like '?' or '@'. UNL navigation begins after the first pipe. *)
URILiteral         ::= (* A string representing a valid URI, conforming to RFC3986 *)
NCName             ::= (* A Non-Colonized Name, as defined in [[XML-NAMES]]. It must not contain ':' and should be compliant with the full Unicode character set allowed by that standard. *)
Integer            ::= [0-9]+
Literal            ::= '"' ( [^"\\] | '\\' . )* '"' | "'" ( [^'\\] | '\\' . )* "'"
    </pre>
  </section>

  <section id="data-mapping" class="appendix">
    <h2>Data Model Mapping</h2>
    <p>
        This section defines how UNL's abstract concepts of <a>Node</a> and <a>Leaf</a> are mapped onto the concrete structures of each major supported format. UNL is a <strong>1-based</strong> language, following the convention of XPath for all positional indexing.
    </p>

    <section>
        <h3>UNL's Conceptual Data Types</h3>
        <p>To describe transformations accurately, UNL uses a set of conceptual data types.</p>
        <dl>
            <dt><code>Node</code></dt>
            <dd>The base type for any navigable structure. It has several specializations:
                <ul>
                    <li><code>Node(Object)</code>: An unordered collection of key-value pairs, similar to a JSON object.</li>
                    <li><code>Node(Array)</code>: An ordered collection of other Nodes or Leaves, similar to a JSON array or a set of CSV rows.</li>
                    <li><code>Node(XML | HTML)</code>: A structure following the XML Infoset model, with elements, attributes, and text.</li>
                    <li><code>Node(Graph)</code>: A structure representing RDF triples.</li>
                    <li><code>Node(Archive)</code>: A virtual filesystem root, containing file and directory nodes.</li>
                </ul>
            </dd>
            <dt><code>Leaf</code></dt>
            <dd>The base type for any terminal, atomic value. It has several specializations:
                <ul>
                    <li><code>Leaf(String)</code>: A Unicode string. This is the most common leaf type.</li>
                    <li><code>Leaf(Binary)</code>: A sequence of raw bytes. This type is not directly inspectable and <em class="rfc2119">MUST</em> be piped to another transformation (e.g., <code>|text</code>, <code>|decomp:gz</code>, or <code>|xml</code>) to be useful.</li>
                    <li><code>Leaf(Number)</code>, <code>Leaf(Boolean)</code>, <code>Leaf(Null)</code>: Primitive data types.</li>
                </ul>
            </dd>
            <dt><code>Sequence(T)</code></dt>
            <dd>An ordered collection of items of type T, for example a <code>Sequence(Node)</code>.</dd>
            <dt><code>ResourceLocator</code></dt>
            <dd>A string that represents a URI or a local file path, used as the initial input for a <code>ResourceQuery</code>.</dd>
        </dl>
    </section>

    <h3>XML</h3>
    <dl>
        <dt><a>Node</a></dt>
        <dd>An XML Element. The document itself is the root node.</dd>
        <dt><a>Leaf</a></dt>
        <dd>An XML Attribute, or a Text node. The value of the attribute or text is the leaf's value.</dd>
    </dl>
    <pre class="example">
&lt;!-- Data --&gt;
&lt;book isbn="123-456"&gt;UNL Guide&lt;/book&gt;

// UNL Queries
book/@isbn     // Returns leaf "123-456"
book/text()    // Returns leaf "UNL Guide"
    </pre>

    <h3>JSON</h3>
    <dl>
        <dt><a>Node</a></dt>
        <dd>A JSON Object (<code>{}</code>) or a JSON Array (<code>[]</code>).</dd>
        <dt><a>Leaf</a></dt>
        <dd>A value within an object or array that is a String, Number, Boolean, or Null.</dd>
    </dl>
    <pre class="example">
// Data
{ "user": { "name": "Alice", "active": true } }

// UNL Queries
user/@name     // Returns leaf "Alice"
user/@active   // Returns leaf true
    </pre>

    <h3>CSV</h3>
    <p>The <code>|csv</code> transformation parses data into an array of nodes. All indexing is 1-based.</p>
    <dl>
        <dt><a>Node</a></dt>
        <dd>The result of the <code>|csv</code> transformation is a single Array Node. Each record (line) in the CSV is mapped to a child Node within this array.</dd>
        <dt><a>Leaf</a></dt>
        <dd>
            An individual cell value within a row. A row's leaves form an ordered collection that can be accessed in two equivalent ways:
            <ul>
                <li><strong>By Name (if header exists):</strong> Using <code>/@name</code>. This is the most readable method.</li>
                <li><strong>By Position (always available):</strong> Using <code>/@*[n]</code>, where <code>n</code> is a 1-based integer. <code>@*</code> selects all leaves, and <code>[n]</code> filters for the n-th position.</li>
            </ul>
        </dd>
    </dl>
    <pre class="example nohighlight">
// Example 1: CSV with header (in "users.csv")
id,name,role,tags
1,Alice,admin,"a,b,c"

// Query 1: Get the 'role' leaf from rows where 'id' leaf is "1"
users.csv|csv/*[@id="1"]/@role          // Returns leaf "admin"

// Query 2: Get the 2nd tag from Alice's record. This requires a nested parse.
users.csv|csv/*[1]/@tags|csv/*[1]/@*[2]    // Returns leaf "b"

// Example 2: Headerless CSV (in "logs.csv")
1687354800,ERROR,auth_service

// Get the 2nd column of the 1st record
logs.csv|csv/*[1]/@*[2]                   // Returns leaf "ERROR"
    </pre>

    <h3>RDF</h3>
    <p>UNL navigates an RDF graph by following predicates (properties).</p>
    <dl>
        <dt><a>Node</a></dt>
        <dd>A resource identified by a URI or a Blank Node, when it acts as a subject or object of a triple.</dd>
        <dt><a>Leaf</a></dt>
        <dd>A Literal value (e.g., a string, number, or date) that is an object of a triple.</dd>
    </dl>
    <pre class="example">
// Data (in Turtle syntax)
@prefix ex: &lt;http://example.org/&gt; .
@prefix foaf: &lt;http://xmlns.com/foaf/0.1/&gt; .

ex:person1 a foaf:Person ;
    foaf:name "Alice" .

// UNL Query (In-Memory Mode, using EQNames)
Q{http://xmlns.com/foaf/0.1/}Person/@name  // Returns leaf "Alice"
    </pre>

    <h3>Archives (zip, tar, etc.)</h3>
    <p>Archives are treated as a virtual filesystem. Both files and directories are modeled as <a>Nodes</a> to allow querying their metadata.</p>
    <dl>
        <dt><a>Node</a></dt>
        <dd>A directory or a file. Directory nodes can contain other nodes. File nodes are terminal for path navigation but expose metadata leaves.</dd>
        <dt><a>Leaf</a></dt>
        <dd>
            Metadata about a file or directory node. When a file <a>node</a> is piped to another transformation, its raw content is used as the input. A standard set of metadata leaves is defined:
            <ul>
                <li><code>@name</code>: The name of the file or directory.</li>
                <li><code>@size</code>: The uncompressed size in bytes (files only).</li>
                <li><code>@compressed_size</code>: The compressed size in bytes (files only).</li>
                <li><code>@modified_date</code>: The modification timestamp.</li>
                <li><code>@is_dir</code>: A boolean that is true if the node is a directory.</li>
            </ul>
        </dd>
    </dl>
     <pre class="example nohighlight">
// Example 1: Select a file node and pipe its content to the XML parser.
my_archive.zip|decomp:zip/docs/report.xml|xml//title

// Example 2: Get the size of a specific file.
my_archive.zip|decomp:zip/docs/report.xml/@size

// Example 3: Filter files by metadata, then pipe their content.
my_archive.zip|decomp:zip/*[@is_dir=false() and @size>1000]|xml//important
    </pre>

  </section>

</body>
</html>
